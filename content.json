{"meta":{"title":"欢迎来到我的个人博客","subtitle":"","description":"","author":"Yekezhen","url":"http://example.com","root":"/"},"pages":[{"title":"文章归档","date":"2022-01-14T04:06:23.570Z","updated":"2022-01-14T03:59:14.282Z","comments":true,"path":"archive.html","permalink":"http://example.com/archive.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-14T03:55:17.000Z","updated":"2022-01-14T03:56:40.162Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"正则表达式","slug":"正则表达式","date":"2022-01-18T04:42:51.000Z","updated":"2022-01-18T12:45:40.792Z","comments":true,"path":"2022/01/18/正则表达式/","link":"","permalink":"http://example.com/2022/01/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的底层实现12345String content =&quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年&quot;+ &quot;6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平&quot; + &quot;台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台&quot; + &quot;的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用于基&quot; + &quot;于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。&quot;; 目标：匹配所有四个数字 \\\\d 表示任意一个数字 1String regStr =&quot;\\\\d\\\\d\\\\d\\\\d&quot; //四个数字 创建模式对象[即正则表达式对象] 1Pattern pattern = Pattern.compile(regStr); 创建匹配器 1Matcher matcher = pattern.matcher(content); 开始匹配 123 while(matcher.find())&#123; System.out.println(&quot;找到: &quot;+ matcher.group(0));&#125; 效果图 底层原理matcher.find()的作用 根据指定的规则，定位满足条件的子字符串(比如1998) 找到后将，子字符串的索引记下，记下初始的位置到matcher对象的属性中即是 （数字1）的初始位置0 记入到 groups[0]=0; （数字8）的结束位置4 记入到 groups[1]=4; 并计入 结束位置 ‘4’ oldlast为下一次扫描做开始位置。 matcher.group(0)的作用 group的源代码 12 return GetSubSequence(groups[group+2],groups[group*2+1]).toString();&#125; 主函数内调用groups(0)，实际上在调用matcher.group(0)时，是将gourp[0]到gourp[1] [0，4）的位置进行subString（） 考虑分组情况，如 (19)(98),同理group[0]=0，先索引总的长度计入group[1]=4；第一组 (1 9)的索引计入到 group[2]=0,group[3]=2;第二组 (9 8)的索引计入到 groups[4]=2,groups[5]=4; 一些常用的符号 一道简单的应用 AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Main &#123; public static void main(String[] args) &#123; String content = &quot;&quot;; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; content = scanner.next(); int year = 0, month = 0, day = 0; String regStr = &quot;(\\\\d&#123;4&#125;)-(\\\\d&#123;2&#125;)-(\\\\d&#123;2&#125;)&quot;; Pattern pattern = Pattern.compile(regStr); Matcher matcher = pattern.matcher(content); boolean flag = false; while (matcher.find()) &#123; year = Integer.parseInt(matcher.group(1)); month = Integer.parseInt(matcher.group(2)); day = Integer.parseInt(matcher.group(3)); if (month == 1||month==3||month==5||month==7||month==8||month==10||month==12) &#123; if (day &gt;= 1 &amp;&amp; day &lt;= 31) &#123; flag = true; break; &#125; &#125; else if (month == 2) &#123; if (isLeepyear(year)) &#123; if (day &gt;= 1 &amp;&amp; day &lt;= 29) &#123; flag = true; &#125; &#125; else&#123; if(day&gt;=1&amp;&amp;day&lt;=28) flag=true; &#125; &#125; else if(month==4||month==6||month==9||month==11)&#123; if(day&gt;=1&amp;&amp;day&lt;=30)&#123; flag=true; &#125; &#125; else&#123; flag=false; &#125; &#125; if(flag)&#123; System.out.println(&quot;yes&quot;); &#125; else&#123; System.out.println(&quot;no&quot;); &#125; &#125; &#125; public static boolean isLeepyear(int year) &#123; return year % 4== 0 &amp;&amp; year%100!=0||year%400==0; &#125;&#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"栈","slug":"栈","date":"2022-01-17T05:42:44.000Z","updated":"2022-01-18T12:46:35.960Z","comments":true,"path":"2022/01/17/栈/","link":"","permalink":"http://example.com/2022/01/17/%E6%A0%88/","excerpt":"","text":"Quick Start创建栈实现栈的思路分析1.使用数组模拟栈2.定义一个变量TOP来表示栈顶，初始化为-13.入栈的操作，当有数据加入到栈时，top++;stack{top}=data;4.出栈的操作，int value=stack[–top];return value; java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.Scanner;public class ArrStackDemo &#123; public static void main(String[] args) &#123; ArrayStack stack = new ArrayStack(3); Scanner scanner = new Scanner(System.in); char key=&#x27; &#x27;; boolean loop=true; while(loop) &#123; System.out.printf(&quot;l(List):显示栈\\n&quot;); System.out.printf(&quot;e(exit):退出\\n&quot;); System.out.printf(&quot;p(push):入栈\\n&quot;); System.out.printf(&quot;o(pop):出栈\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case&#x27;l&#x27;: stack.list(); break; case&#x27;e&#x27;: scanner.close(); loop=false; break; case&#x27;p&#x27;: System.out.println(&quot;请输入一个数据&quot;); int value=scanner.nextInt(); stack.push(value); break; case&#x27;o&#x27;: try &#123; int res=stack.pop(); System.out.printf(&quot;出栈的数据为:%d\\n&quot;,res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; &#125; &#125; System.out.println(&quot;退出\\n&quot;); &#125; &#125;class ArrayStack&#123; private int maxSize;//栈的大小 private int[] stack;//用数组模拟栈 private int top=-1;//表示栈顶，初始化为-1 public ArrayStack(int maxSize) &#123; this.maxSize=maxSize; stack=new int[maxSize]; &#125; //栈满 public boolean isFull() &#123; return top==maxSize-1; &#125; //栈空 public boolean isEmpty() &#123; return top==-1; &#125; public void push(int value) &#123; if(isFull()) &#123; System.out.printf(&quot;栈满，无法继续存放\\n&quot;); return; &#125; top++; stack[top]=value; &#125; public int pop() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;栈为空，无法取得数据\\n&quot;); &#125;else &#123; return stack[top--]; &#125; &#125; //显示栈的情况[遍历栈],从栈顶开始; public void list() &#123; if(isEmpty()) &#123; System.out.println(&quot;栈空，无法获取数据&quot;); return; &#125; for(int i=top;i&gt;=0;i--) &#123; System.out.printf(&quot;Stack[%d]=%d\\n&quot;,i,stack[i]); &#125; &#125;&#125; 程序测试 简单的中缀计算器①在一个创建好的栈的基础上先提供方法(①查看栈顶②计算方法③比较运算符优先级)②创建两个栈，存放数据和存放符号③在Main函数内用一个辅助变量index去索引整个表达式 判断几种情况 一 若index所指向的变量是运算符则 ①如果oper栈不为空，则先与oper栈顶的运算符比较，若小于等于栈顶的运算符，则在数栈内弹出两个数字在符号栈弹出一个符号进行运算，然后再将符号压入栈中 ②若oper栈为空，则符号直接入栈 二 若index所指向的变量是数字 ①判断数字有几位，然后直接压入栈中 ④ 最后存放在数字栈中的即是结果 java版本代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; ArrayStack numstack = new ArrayStack(10); ArrayStack operstack = new ArrayStack(10); String expression = &quot;7*2*2-5+1-5+3-4&quot;; Scanner scanner = new Scanner(System.in); int index=0; int num1=0;int num2=0;int oper=0;int res=0; char ch=&#x27; &#x27;; String keepNum=&quot;&quot;; while(true)&#123; ch= expression.substring(index,index+1).charAt(0); if(operstack.isOper(ch))&#123; if(!operstack.isEmpty())&#123; if(operstack.priority(ch)&lt;=operstack.priority(operstack.peek())) &#123; num1 = numstack.pop(); num2 = numstack.pop(); oper = operstack.pop(); res = numstack.cal(num1, num2, oper); System.out.printf(&quot;%d\\n&quot;,res); numstack.push(res); operstack.push(ch); &#125;else&#123; operstack.push(ch); &#125; &#125;else&#123; operstack.push(ch); &#125; &#125;else&#123; keepNum+=ch; if(index==expression.length()-1) &#123; numstack.push(Integer.parseInt(keepNum)); &#125;else&#123; if(operstack.isOper(expression.substring(index+1,index+2).charAt(0)))&#123; numstack.push(Integer.parseInt(keepNum)); keepNum=&quot;&quot;; &#125; &#125; &#125; index++; if(index&gt;=expression.length())&#123; break; &#125; &#125; while(true)&#123; numstack.list(); if(operstack.isEmpty())&#123; break; &#125; num1 = numstack.pop(); num2 = numstack.pop(); oper = operstack.pop(); if(!operstack.isEmpty()) &#123; if(operstack.peek()==oper&amp;&amp;oper==&#x27;-&#x27;) &#123; num1 = num1 * -1; &#125; &#125; res = numstack.cal(num1, num2, oper); numstack.push(res); &#125; System.out.printf(&quot;表达式%s = %d\\n&quot;,expression,numstack.pop()); &#125;&#125;class ArrayStack&#123; private int maxSize;//栈的大小 private int[] stack;//用数组模拟栈 private int top=-1;//表示栈顶，初始化为-1 public ArrayStack(int maxSize) &#123; this.maxSize=maxSize; stack=new int[maxSize]; &#125; //栈满 public boolean isFull() &#123; return top==maxSize-1; &#125; //栈空 public boolean isEmpty() &#123; return top==-1; &#125; public void push(int value) &#123; if(isFull()) &#123; System.out.printf(&quot;栈满，无法继续存放\\n&quot;); return; &#125; top++; stack[top]=value; &#125; public int pop() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;栈为空，无法取得数据\\n&quot;); &#125;else &#123; return stack[top--]; &#125; &#125; //显示栈的情况[遍历栈],从栈顶开始; public void list() &#123; if(isEmpty()) &#123; System.out.println(&quot;栈空，无法获取数据&quot;); return; &#125; for(int i=top;i&gt;=0;i--) &#123; System.out.printf(&quot;Stack[%d]=%d\\n&quot;, i, stack[i]); &#125; &#125; public int priority(int oper)&#123; if(oper==&#x27;*&#x27;||oper==&#x27;/&#x27;)&#123; return 1; &#125; else if(oper==&#x27;+&#x27;||oper==&#x27;-&#x27;)&#123; return 0; &#125; else&#123; return -1; &#125; &#125; public boolean isOper(int oper)&#123; return oper==&#x27;+&#x27;||oper==&#x27;-&#x27;||oper==&#x27;*&#x27;||oper==&#x27;/&#x27;; &#125; public int cal(int num1,int num2,int oper)&#123; int res=0; switch(oper)&#123; case &#x27;+&#x27;: res=num1+num2; break; case &#x27;-&#x27;: res=num2-num1; break; case &#x27;*&#x27;: res=num1*num2; break; case &#x27;/&#x27;: res=num2/num1; break; &#125; return res; &#125; public int peek()&#123; return stack[top]; &#125;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"链表","slug":"链表","date":"2022-01-16T11:56:16.000Z","updated":"2022-01-16T12:27:53.361Z","comments":true,"path":"2022/01/16/链表/","link":"","permalink":"http://example.com/2022/01/16/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"Quick Start链表是一种物理存储单元上非连续、非顺序的存储结构，由一个或多个结点组成，节点可分为数据域与指针域。链表在插入数据时的复杂度比线性表和顺序表低很多，因此当一组很庞大数据需要管理时，采用链表可以大大增加计算机效率。 本文介绍两种类型的链表 ① 单向链表 ② 环状链表 单向链表单向链表只需每次用辅助指针将链表遍历至最后一个节点，再将最后一个节点的指针域指向要插入的节点即可。或是用头插法，双指针法都可以。 java版本代码实现简单的单向链表的增删添改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package Main;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; HeroNode hero1 = new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;); HeroNode hero2 = new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;); HeroNode hero3 = new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;); HeroNode hero4 = new HeroNode(3,&quot;小卢&quot;,&quot;玉麒麟&quot;); SingleLinkedlist single = new SingleLinkedlist(); single.addByorder(hero2);single.addByorder(hero1);single.addByorder(hero3); single.list(); single.Del(2); System.out.printf(&quot;-----删除后-----------\\n&quot;); single.list(); System.out.printf(&quot;-----修改后-----------\\n&quot;); single.modify(hero4); single.list(); &#125;&#125;class HeroNode&#123; public int no; public String name; public String nickname; public HeroNode next; public HeroNode(int Hno,String Hname,String Hnickname) &#123; //构造器 this.no=Hno; this.name=Hname; this.nickname=Hnickname; &#125; @Override public String toString() &#123; return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;; &#125;&#125;class SingleLinkedlist&#123; private HeroNode head= new HeroNode(0,&quot;&quot;,&quot;&quot;); public void add(HeroNode node) &#123; HeroNode cur=head; while(true) &#123; if(cur.next==null) &#123;//遍历到最后一个 break; &#125; cur=cur.next; &#125; cur.next=node; //将新的Node结点插入进去 &#125; public void list() &#123; HeroNode cur=head.next; if(head.next==null) &#123; System.out.printf(&quot;链表为空&quot;); return; &#125; while(cur!=null) &#123; System.out.println(cur); cur=cur.next; &#125; &#125; public void addByorder(HeroNode node) &#123; if(head.next==null) &#123; //第一种情况，如果没有结点 那node就为第一个结点 head.next=node; return; &#125; else if(head.next.no&gt;node.no) &#123; 第二种情况 若node结点的num值比第一个结点的还小 node.next=head.next; head.next=node; return; &#125; else &#123; HeroNode cur=head,pre = null; while(cur!=null) &#123; if(cur.no&gt;node.no) &#123; //第三种，插入在中间和最后一个 break; &#125; pre=cur; cur=cur.next; &#125; node.next=cur; pre.next=node; return; &#125; &#125; public void Del(int no) &#123; //按照序号来找即可 if(head.next==null) &#123; System.out.printf(&quot;链表不存在\\n&quot;); return; &#125; HeroNode cur=head.next; boolean flag=false; while(cur!=null) &#123; if(cur.next.no==no) &#123; //这里必须是cur的下一个结点的值 flag=true; break; &#125; cur=cur.next; &#125; if(flag) &#123; cur.next=cur.next.next; return; &#125; else &#123; System.out.printf(&quot;不存在该节点\\n&quot;); return; &#125; &#125; public void modify(HeroNode node) &#123; if(head.next==null) &#123; System.out.printf(&quot;链表不存在\\n&quot;); return; &#125; HeroNode cur=head.next; boolean flag=false; while(cur!=null) &#123; if(cur.no==node.no) &#123; flag=true; break; &#125; cur=cur.next; &#125; if(flag) &#123; cur.name=node.name; cur.nickname=node.nickname; return; &#125; else &#123; System.out.printf(&quot;不存在该节点\\n&quot;); return; &#125; &#125; &#125; 效果图 环形链表环形链表通过 一个辅助指针（first）指向链表的第一个结点，再通过一个cur指针遍历链表，之后将cur指向的结点的next域指向first 形成环状 java版本代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package Main;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); CircleSingleLinkedList circle = new CircleSingleLinkedList(); circle.addBoy(5); circle.list(); &#125; &#125;class CircleSingleLinkedList&#123; private Boy first =new Boy(-1); public void addBoy(int nums) &#123; if(nums&lt;1) &#123; System.out.printf(&quot;数据错误\\n&quot;); return; &#125; Boy curBoy=null;//辅助指针 for(int i=1;i&lt;=nums;i++) &#123; Boy boy=new Boy(i); if(i==1) &#123; //如果是第一个 就交代first指针与cur指针 first=boy; first.setNext(first); curBoy=first; &#125;else &#123; curBoy.setNext(boy); //cur依次向后移，但是first始终不变 boy.setNext(first); //这步是为了连成环状 curBoy=boy; &#125; &#125; &#125; public void list() &#123; if(first==null) &#123; System.out.printf(&quot;链表为空，没有数据\\n&quot;); return; &#125; Boy cur=first; while(cur!=null) &#123; if(cur.getNext()==first) &#123; System.out.printf(&quot;%d\\n&quot;,cur.getNo()); break; &#125; else &#123; System.out.printf(&quot;%d-&gt;&quot;,cur.getNo()); &#125; cur=cur.getNext(); &#125; &#125; &#125;class Boy&#123; private int no; private Boy next; public Boy(int no) &#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125; 约瑟夫环 具体思路 java代码（老版本oj能AC,不知道为什么新平台一直提示scanner错误） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); CircleSingleLinkedList circle = new CircleSingleLinkedList(); while(scanner.hasNext()) &#123; int Case=0; int data[]=new int[100]; int T=scanner.nextInt(),i; for(i=0;i&lt;T;i++) &#123; int n,m; Case++; n=scanner.nextInt(); m=scanner.nextInt(); circle.addBoy(n); for(int j=0;j&lt;n;j++) &#123; data[j]=scanner.nextInt(); &#125; System.out.printf(&quot;Case %d:&quot;,Case); circle.countBoy(1,m,n,data); &#125; &#125; scanner.close();&#125; &#125;class CircleSingleLinkedList&#123; private Boy first =new Boy(-1); public void addBoy(int nums) &#123; if(nums&lt;1) &#123; System.out.printf(&quot;数据错误\\n&quot;); return; &#125; Boy curBoy=null; for(int i=1;i&lt;=nums;i++) &#123; Boy boy=new Boy(i); if(i==1) &#123; first=boy; first.setNext(first); curBoy=first; &#125;else &#123; curBoy.setNext(boy); boy.setNext(first); curBoy=boy; &#125; &#125; &#125; public void list() &#123; if(first==null) &#123; System.out.printf(&quot;链表为空，没有数据\\n&quot;); return; &#125; Boy cur=first; while(cur!=null) &#123; if(cur.getNext()==first) &#123; System.out.printf(&quot;%d\\n&quot;,cur.getNo()); break; &#125; else &#123; System.out.printf(&quot;%d-&gt;&quot;,cur.getNo()); &#125; cur=cur.getNext(); &#125; &#125; public void countBoy(int startNo,int countNum,int nums,int data[]) &#123; if(first==null||startNo&lt;1||startNo&gt;nums) &#123; System.out.printf(&quot;参数错误&quot;); return; &#125; Boy helper = first; while(true) &#123; if(helper.getNext()==first) &#123; break; &#125; helper=helper.getNext(); &#125; for(int j=0;j&lt;startNo-1;j++) &#123; 先指到开始的位置 first=first.getNext(); helper=helper.getNext(); &#125; while(true) &#123; if(helper==first) &#123; break; &#125; for(int j=0;j&lt;countNum-1;j++) &#123; //移动几次 first=first.getNext(); helper=helper.getNext(); &#125; System.out.printf(&quot;%d-&gt;&quot;,first.getNo()); countNum=data[first.getNo()-1]; first=first.getNext(); helper.setNext(first); &#125; System.out.printf(&quot;%d\\n&quot;,first.getNo()); &#125; &#125;class Boy&#123; private int no; private Boy next; public Boy(int no) &#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"队列","slug":"ceshi","date":"2022-01-14T12:49:31.123Z","updated":"2022-01-14T12:57:57.360Z","comments":true,"path":"2022/01/14/ceshi/","link":"","permalink":"http://example.com/2022/01/14/ceshi/","excerpt":"","text":"队列是一种线型的结构，与栈不同，队列的数据是先进先出。##数组单向队列 单向队列只能使用一次，即达到最大容量后无法继续增添删改，由Maxsize（最大容量），rear（队列尾）和front（队列头）三个变量进行数据的进队和出队 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129$ public class Main&#123; public static void main(String[] args) &#123; // ArrayQueue arrayQueue = new ArrayQueue(3); char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125;class ArrayQueue&#123; private int maxSize; private int front; private int rear; private int[] arr; //创建队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize=arrMaxSize; arr=new int[maxSize]; front =-1;//指向队列的头部，分析出front是队列头的前一个位置 rear=-1;//指向队列尾，指向队列尾的数据 &#125; //判断队列是否满 public boolean isFull() &#123; return rear==maxSize-1; &#125; public boolean isEmpty() &#123; return rear==front; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if(isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; rear++;//让rear后移 arr[rear]=n; &#125; //出队列 public int getQueue() &#123; if(isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; front++;//后移到第一个 return arr[front]; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; for(int i=0;i&lt;arr.length;i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i, arr[i]); &#125; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front+1]; &#125;&#125; ##环形队列 与单向队列不同，环形队列可以多次反复的使用，其原因是rear与front指针在指向下一个数组位置是都要对maxsize进行取余 因此可以反复使用 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127$ public class Main&#123; public static void main(String[] args) &#123; System.out.printf(&quot;测试数组环形队列~~~\\n&quot;); CircleArray arrayQueue = new CircleArray(4); // 设置为4，实则为3 //因为预留了一个位置 char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125; class CircleArray &#123; private int maxSize; private int front; private int rear; private int[] arr; public CircleArray(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; public boolean isEmpty() &#123; return front == rear; &#125; public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; arr[rear] = n; rear = (rear + 1) % maxSize; //将rear后移，这里必须考虑取模，可能是一圈两圈 n圈 &#125; public int getQueue() &#123; if (isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; int val = arr[front]; front = (front + 1) % maxSize; return val; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; //思路 从front开始遍历，遍历多少个元素 //遍历整个数组数据，(rear+maxSize-front)%maxsize for(int i=0;i&lt;front+size();i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i%maxSize, arr[i%maxSize]); &#125; &#125; public int size() &#123; return (rear+maxSize-front)%maxSize; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front]; &#125; &#125; ##学校的OJ题 此题只需将 0-k-1 的数据入队，再将k-m的数据输出，再将 0-K-1的数据出队即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) &#123; int m,n,i; m=scanner.nextInt(); n=scanner.nextInt(); if(m==0&amp;&amp;n==0) break; int data[]=new int[m+1]; queue Queue = new queue(m); for(i=0;i&lt;m;i++) &#123; data[i]=scanner.nextInt(); &#125; for(i=0;i&lt;n;i++) &#123; Queue.add(data[i]); &#125; for(;i&lt;m;i++) &#123; System.out.printf(&quot;%d &quot;,data[i]); &#125; for(i=0;i&lt;n;i++) &#123; int res=Queue.getqueue(); if(i==n-1) System.out.printf(&quot;%d\\n&quot;,res); else System.out.printf(&quot;%d &quot;,res); &#125; &#125; &#125; &#125;class queue&#123; Scanner scanner =new Scanner(System.in); private int rear; private int front; private int Maxsize; private int[] arr; public queue(int maxsize) &#123; Maxsize=maxsize; arr=new int[Maxsize]; rear=-1; front=-1; &#125; public void add(int n) &#123; arr[++rear]=n; &#125; public int getqueue() &#123; return arr[++front]; &#125; &#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-01-13T13:36:50.434Z","updated":"2022-01-14T08:39:47.842Z","comments":true,"path":"2022/01/13/hello-world/","link":"","permalink":"http://example.com/2022/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}],"categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"},{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}