{"meta":{"title":"欢迎来到我的个人博客","subtitle":"","description":"","author":"Yekezhen","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-01-14T03:55:17.000Z","updated":"2022-01-14T03:56:40.162Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"文章归档","date":"2022-01-14T04:06:23.570Z","updated":"2022-01-14T03:59:14.282Z","comments":true,"path":"archive.html","permalink":"http://example.com/archive.html","excerpt":"","text":""}],"posts":[{"title":"图","slug":"图","date":"2022-02-04T11:42:05.000Z","updated":"2022-02-05T12:22:24.987Z","comments":true,"path":"2022/02/04/图/","link":"","permalink":"http://example.com/2022/02/04/%E5%9B%BE/","excerpt":"","text":"图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点 为什么要有图 前面我们学了线性表和树 线性表局限于一个直接前驱和一个直接后继的关系 树也只能有一个直接前驱也就是父节点 当我们需要表示多对多的关系时， 这里我们就用到了图 常用概念 顶点：也就是结点 边：顶点和顶点的路线 路径 由一个点到另一个点的路线 无向图 相互链接 A-&gt;B B-&gt;A 有向图 与无向图相反 带权图 就是顶点带有权值 图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。 邻接矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;public class graph &#123; private ArrayList&lt;String&gt; vertexList;//存储顶点的集合 private int edges[][];//存储图对应的邻接矩阵 private int numOfEdges;//表示对应边的数目 private boolean isVisited[]; public static void main(String[] args)&#123; int n=5;//结点的个数 String VertexValue[]=&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;; //创建图对象 graph G = new graph(n);//实例化对象 //循环添加顶点 for(String value:VertexValue)&#123; G.insertVertex(value); &#125; //添加边 //A-B A-C B-C B-D B-E G.insertEdge(0,1,1); G.insertEdge(0,2,1); G.insertEdge(1,2,1); G.insertEdge(1,3,1); G.insertEdge(1,4,1); G.listGrapharray(); // G.dfs(); G.bfs(); &#125; //构造器 public graph(int n)&#123; edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(n); isVisited = new boolean[n]; numOfEdges=0; &#125; //插入结点 public void insertVertex(String vertex)&#123; vertexList.add(vertex); &#125; //添加边 /** * * @param v1 v1 表示点的下表便是第几个顶点 行 * @param v2 v2 代表第二个顶点对应的下标 列 * @param weight 表示值 这里1是相连，0是不相连 */ public void insertEdge(int v1,int v2,int weight)&#123; edges[v1][v2]=weight; edges[v2][v1]=weight; numOfEdges++; &#125; //图中常用的方法 //图中结点的个数 public int getNumofVertex()&#123; return vertexList.size(); &#125; //得到边的数目 public int getNumOfedges()&#123; return numOfEdges; &#125; //反对下标对应的数据 和输入有关 public String getvalueByIndex(int i)&#123; return vertexList.get(i); &#125; //返回权值 public int getWeight(int v1,int v2)&#123; return edges[v1][v2]; &#125; //显示矩 public void listGrapharray()&#123; for(int[] link:edges)&#123; System.out.println(Arrays.toString(link)); &#125; &#125;&#125; 通过代码就可以将图用二维数组的方式表示出来","categories":[],"tags":[]},{"title":"二叉树","slug":"二叉树","date":"2022-01-29T12:17:10.000Z","updated":"2022-02-04T09:50:41.202Z","comments":true,"path":"2022/01/29/二叉树/","link":"","permalink":"http://example.com/2022/01/29/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"二叉树的增删改查 1. 前序遍历 是按父结点并从左向右遍历的方法 中序遍历 从左孩子的最后一个结点开始从左向右遍历 3.后续遍历 从右孩子的最后一个结点开始遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import java.util.Stack;public class Binarytree &#123; public static void main(String[] args)&#123; HeroNode root = new HeroNode(1,&quot;宋江&quot;); Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); HeroNode node1 = new HeroNode(2,&quot;卢俊义&quot;); HeroNode node2 = new HeroNode(3,&quot;吴用&quot;); HeroNode node3 = new HeroNode(4,&quot;林冲&quot;); HeroNode node4= new HeroNode(5,&quot;关胜&quot;); Binnarytree binnarytree = new Binnarytree(); binnarytree.setRoot(root); root.setLeft(node1); root.setRight(node2); node2.setRight(node3); node2.setLeft(node4);// System.out.println(&quot;前序遍历&quot;);// binnarytree.preOder();// System.out.println(&quot;中序遍历&quot;);// binnarytree.infixoder();// System.out.println(&quot;后序遍历&quot;);// binnarytree.postorder(); System.out.println(&quot;删除前&quot;); binnarytree.preOder(); System.out.println(&quot;删除后&quot;); binnarytree.del(5); binnarytree.preOder(); &#125;&#125;class HeroNode&#123; private int no; public HeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; private String name; private HeroNode left; private HeroNode right; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return &quot;HeroNode&#123;&quot; + &quot;no=&quot; + no + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public void setName(String name) &#123; this.name = name; &#125;//前序遍历的方法 public void preOder()&#123; System.out.println(this); //向左子树递归 if(this.left!=null)&#123; this.left.preOder(); &#125; //向右子树递归 if(this.right!=null)&#123; this.right.preOder(); &#125; &#125; //中序遍历 public void infixOrder()&#123; if(this.left!=null)&#123; this.left.infixOrder(); &#125; System.out.println(this); //向右遍历 if(this.right!=null)&#123; this.right.infixOrder(); &#125; &#125; public void postOder()&#123; if(this.left!=null)&#123; this.left.postOder(); &#125; if(this.right!=null)&#123; this.right.postOder(); &#125; System.out.println(this); &#125; public void del(int no)&#123; if(this.left!=null&amp;&amp;this.left.no==no)&#123; this.left=null; return; &#125; if(this.right!=null&amp;&amp;this.right.no==no)&#123; this.right=null; return; &#125; if(this.left!=null)&#123; this.left.del(no); &#125; if(this.right!=null)&#123; this.right.del(no); &#125; &#125; &#125;class Binnarytree&#123; private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; public void preOder()&#123; if(this.root!=null)&#123; this.root.preOder(); &#125; else&#123; System.out.println(&quot;二叉树为空无法遍历&quot;); &#125; &#125; public void infixoder()&#123; if(this.root!=null)&#123; this.root.infixOrder(); &#125; else&#123; System.out.println(&quot;二叉树为空无法遍历&quot;); &#125; &#125; public void postorder()&#123; if(this.root!=null)&#123; this.root.postOder(); &#125; else&#123; System.out.println(&quot;二叉树为空无法遍历&quot;); &#125; &#125; public void del(int no)&#123; if(root==null)&#123; System.out.println(&quot;空树!!不能删除&quot;); &#125; else&#123; if(root.getNo()==no)&#123; root=null; &#125; else&#123; root.del(no); &#125; &#125; &#125;&#125; 顺序存储二叉树 顾名思义，用数组存储的方式来进行模拟二叉树，顺序二叉树通常只考虑完全二叉树 父结点的索引为 （n-1）/2 左孩子的索引为 i*2+1 右孩子的索引为 i*2+2 线索化二叉树 n个结点的二叉链表中含有n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为\"线索\"） 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点一个结点的后一个结点，称为后继结点 12345678910111213141516171819202122232425262728293031323334353637public void threadedNode(HeroNode1 node)&#123; //如果node==null，不能线索化 if(node==null)&#123; return; &#125; //先线索化左子树 threadedNode(node.getLeft()); //线索化当先结点 if(node.getLeft()==null)&#123; node.setLeft(pre); node.setLeftType(1); &#125; if(pre!=null&amp;&amp;pre.getRight()==null)&#123; pre.setRight(node); pre.setRightType(1); &#125; pre=node; //线索化右结点 threadedNode(node.getRight()); &#125; public void threadedNodelist()&#123; HeroNode1 cur=root; //遍历线索化二叉树的方法 while(cur!=null) &#123; //循环找到lefttype==1的结点 //后面随着遍历而变化，因为当left==1的时候，该结点是按照线索化进行的有效节点 while (cur.getLeftType() == 0) &#123; cur = cur.getLeft(); &#125; System.out.println(cur); while (cur.getRightType() == 1) &#123; cur = cur.getRight(); System.out.println(cur); &#125; cur = cur.getRight(); &#125; &#125; 堆排序 堆排序是一个一直在重建大顶堆然后父结点与最小的叶子交换的过程，其时间复杂度是对数 具体代码 1234567891011121314151617181920212223242526272829303132333435363738 import java.util.Arrays;public class HeapSort &#123; public static void main(String[] args)&#123; int arr[]=&#123;3,8,6,2,7&#125;; headSort(arr); &#125; public static void headSort(int arr[])&#123; int temp=0; System.out.println(&quot;堆排序&quot;); for(int i=arr.length/2-1;i&gt;=0;i--)&#123; adjustHeap(arr,i, arr.length); &#125; for(int j= arr.length-1;j&gt;0;j--)&#123; temp=arr[j]; arr[j]=arr[0]; arr[0]=temp; adjustHeap(arr,0,j); &#125; System.out.println(&quot;数组=&quot;+ Arrays.toString(arr)); &#125; public static void adjustHeap(int arr[],int i,int length)&#123; int temp=arr[i];//从父结点开始，将父结点存入到temp中 for(int k=i*2+1;k&lt;length;k=k*2+1)&#123;//从父结点的左孩子开始 if(k+1&lt;length&amp;&amp;arr[k]&lt;arr[k+1])&#123; //比较左右孩子大小 k++;//如果右孩子大于左孩子，则调右孩子 &#125; if(arr[k]&gt;temp)&#123; arr[i]=arr[k];//父结点与孩子交换 i=k;//指向孩子结点 &#125; else&#123; break; &#125; &#125; arr[i]=temp; &#125;&#125; 二叉排序树 对于二叉排序树的某一个父结点，则一定该父结点的权值一定大于左孩子且小于右孩子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185public class BinarySeachTree &#123; public static void main(String[] args)&#123; int arr[]=&#123;7,3,10,12,5,1,9,2&#125;; BinarysortTree tree = new BinarysortTree(); for(int i=0;i&lt;arr.length;i++)&#123; tree.add(new snode(arr[i])); &#125; tree.infix(); tree.del(1); tree.infix(); &#125;&#125;class snode&#123; int value; snode left; snode right; public snode(int value)&#123; this.value=value; &#125; public void add(snode node)&#123; if(node==null)&#123; return; &#125; if(node.value&lt;this.value)&#123; //如果要添加的结点的值小于当前结点的值 则向左递归 if(this.left==null)&#123; this.left=node; &#125; else&#123; this.left.add(node); &#125; &#125; else&#123; if(this.right==null)&#123; //如果要添加的结点的值大于当前结点的值 则向右递归 this.right=node; &#125; else&#123; this.right.add(node); &#125; &#125; &#125; public void infix()&#123; if(this.left!=null)&#123; this.left.infix(); &#125; System.out.println(this.value); if(this.right!=null)&#123; this.right.infix(); &#125; &#125; //value是要删除的值，找得到返回该结点，找不到返回null public snode search(int value)&#123; if(value==this.value)&#123; return this; &#125; else if(value&lt;this.value)&#123;//因为是二叉排序树，所以比this小的数该往左树查找 if(this.left==null)&#123; return null; &#125; return this.left.search(value); &#125; else&#123; if(this.right==null)&#123; return null; &#125; return this.right.search(value); &#125; &#125; public snode searchParent(int value)&#123; if((this.left!=null&amp;&amp;this.left.value==value)|| (this.right!=null&amp;&amp;this.right.value==value))&#123; return this; &#125; else&#123; //如果查找的值小于当前结点，并且当前结点的左子结点不为空，则向左遍历 if(value&lt;this.value&amp;&amp;this.left!=null)&#123; return this.left.searchParent(value); &#125; else if(value&gt;=this.value&amp;&amp;this.right!=null)&#123; //因为添加有相同的元素时是往右边添加 return this.right.searchParent(value);//向右子树查找 &#125; else&#123; //有可能树只有一个结点或者没有父结点 return this; &#125; &#125; &#125;&#125;class BinarysortTree&#123; private snode root; public void add(snode node)&#123; if(root==null)&#123; root=node; &#125; else&#123; root.add(node); &#125; &#125; public void infix()&#123; if(root!=null)&#123; root.infix(); &#125; else&#123; System.out.println(&quot;树为空&quot;); &#125; &#125; public snode search(int value)&#123; if(root==null)&#123; return null; &#125; else&#123; return root.search(value); &#125; &#125; public snode searchParnt(int value)&#123; if(root==null)&#123; return null; &#125; else&#123; return root.searchParent(value); &#125; &#125; public void del(int value)&#123; if(root==null)&#123; return; &#125; else&#123; snode targetNode = search(value); if(targetNode==null)&#123; return; &#125; if(root.left==null&amp;&amp;root.right==null)&#123; root=null; return; &#125; snode parent = searchParnt(value); //如果删除的是叶子结点 if(targetNode.left==null&amp;&amp;targetNode.right==null)&#123; //判断targetNode 是父结点 左孩子还是右孩子 if(parent.left!=null&amp;&amp;parent.left.value==value)&#123; //是左结点 parent.left=null; &#125; else if(parent.right!=null&amp;&amp;parent.right.value==value)&#123;//是右节点 parent.right=null; &#125; &#125; else if(targetNode.left!=null&amp;&amp;targetNode.right!=null)&#123;//删除有两颗子树的结点 int minval= delRightTreeMin(targetNode.right); //从右子树找最小的值 targetNode.value=minval; //替换 &#125; else&#123;//删除只有一个孩子的结点 //删除的结点只有左孩子 if(targetNode.left!=null)&#123; if(parent!=null) &#123; //如果targetNode是Parent的左子结点 if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123;//如果targetNode是Parent的右子结点 parent.right = targetNode.left; &#125; &#125;else&#123; root=targetNode.left; &#125; &#125; else&#123; //要删除的结点只有右孩子 if(parent!=null) &#123; if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; parent.right = targetNode.right; &#125; &#125;else&#123; targetNode.right=null; &#125; &#125; &#125; &#125; &#125; public int delRightTreeMin(snode node)&#123; snode target =node; while(target.left!=null)&#123; target=target.left; &#125; del(target.value); return target.value; &#125;&#125; 二叉平衡树 当二叉平衡树的数值为 1，2，3，4，5，6，7时则会变成一条链表，所以要处理该问题，引入了二叉平衡树。 对于每个父结点来说，他的左右孩子的高度差的绝对值不会小于等于2","categories":[],"tags":[]},{"title":"哈希表","slug":"哈希表","date":"2022-01-25T15:34:54.000Z","updated":"2022-01-25T15:42:20.021Z","comments":true,"path":"2022/01/25/哈希表/","link":"","permalink":"http://example.com/2022/01/25/%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"","text":"散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 哈希表是 通过对象数组+链表实现的，比对象数组稍微麻烦一些 底层代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import java.util.Scanner;public class HashTableTest &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); HashTab hashTab= new HashTab(7); String key=&quot;&quot;; while(true)&#123; System.out.println(&quot;[list],输出哈希表&quot;); System.out.println(&quot;[add],添加数据&quot;); System.out.println(&quot;[exit],退出&quot;); System.out.println(&quot;[find],查找数据&quot;); System.out.println(&quot;[del],删除数据&quot;); key=scanner.next(); switch (key)&#123; case &quot;list&quot;: hashTab.list(); break; case &quot;add&quot;: System.out.println(&quot;请输入id&quot;); int num=scanner.nextInt(); System.out.println(&quot;请输入姓名&quot;); String name=scanner.next(); Emp emp = new Emp(num,name); hashTab.add(emp); break; case &quot;exit&quot;: scanner.close(); System.exit(0); break; case &quot;del&quot;: System.out.println(&quot;请输入ID&quot;); num=scanner.nextInt(); hashTab.Del(num); break; case &quot;find&quot;: System.out.println(&quot;请输入ID&quot;); num=scanner.nextInt(); hashTab.Find(num); break; &#125; &#125; &#125;&#125;class Emp&#123; public int id; public String name; public Emp next; public Emp(int id, String name) &#123; this.id = id; this.name = name; &#125;&#125;class EmpLinkedList&#123; private Emp head; public void add(Emp node)&#123; if(head==null)&#123; head=node; return; &#125; if(node.id&lt; head.id)&#123; node.next=head; head=node; return; &#125; else&#123; Emp cur=head,pre=null; while(cur!=null)&#123; if(cur.id&gt;node.id)&#123; break; &#125; pre=cur; cur=cur.next; &#125; node.next=cur; pre.next=node; &#125; &#125; public void list(int id)&#123; if(head==null)&#123; System.out.println(&quot;当前&quot;+id+&quot;号链表为空&quot;); &#125; else&#123; System.out.printf(&quot;当前&quot;+id+&quot;号链表的信息为 &quot;); Emp cur=head; while(cur!=null)&#123; System.out.printf(&quot;=&gt; id = %d,name = %s &quot;,cur.id,cur.name); cur=cur.next; &#125; System.out.println(); &#125; &#125; public Emp Search(int id)&#123; if(head==null)&#123; System.out.println(&quot;链表为空&quot;); return null; &#125; Emp cur=head; while(cur!=null)&#123; if(cur.id==id)&#123; break; &#125; cur=cur.next; &#125; if(cur==null)&#123; System.out.println(&quot;链表为空&quot;); return null; &#125; return cur; &#125; public Emp Del(int id)&#123; if(head==null)&#123; System.out.println(&quot;删除失败链表为空&quot;); return null; &#125; if(head.next==null)&#123; return head=null; &#125; Emp cur=head; while(cur.next!=null)&#123; if(cur.next.id==id)&#123; break; &#125; cur=cur.next; &#125; cur.next=cur.next.next; return cur; &#125;&#125;class HashTab&#123; private EmpLinkedList[] empLinkedListArray; private int size; public HashTab(int size)&#123; this.size=size; empLinkedListArray = new EmpLinkedList[size]; for(int i=0;i&lt;size;i++)&#123; empLinkedListArray[i]= new EmpLinkedList(); &#125; &#125; public void add(Emp node)&#123; int empLinkedlistNo = GetQueue(node.id); empLinkedListArray[empLinkedlistNo].add(node); &#125; public int GetQueue(int num)&#123; return num%size; &#125; public void list()&#123; for(int i=0;i&lt;size;i++)&#123; empLinkedListArray[i].list(i+1); &#125; &#125; public void Find(int id)&#123; int num=GetQueue(id); Emp node =empLinkedListArray[num].Search(id); if(node!=null)&#123; System.out.printf(&quot;数据%d在第%d条中\\n&quot;,node.id,num+1); &#125; else&#123; System.out.println(&quot;未找到数据&quot;); &#125; &#125; public void Del(int id)&#123; int num=GetQueue(id); Emp node= empLinkedListArray[num].Del(id); if(node!=null)&#123; System.out.printf(&quot;数据%d在第%d条中已经删除\\n&quot;,node.id,num+1); &#125; else&#123; System.out.println(&quot;未找到数据||删除成功&quot;); &#125; &#125;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"排序","slug":"排序","date":"2022-01-22T07:54:31.000Z","updated":"2022-01-25T15:35:54.946Z","comments":true,"path":"2022/01/22/排序/","link":"","permalink":"http://example.com/2022/01/22/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"快速排序 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 时间复杂度为 O(nlogn) 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 import java.util.Scanner;public class QuickSort &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; int n=scanner.nextInt(); int arr[] = new int[n]; for(int i=0;i&lt;n;i++)&#123; arr[i]=scanner.nextInt(); &#125; QuickSort(arr,0,arr.length-1); for(int i=0;i&lt;n;i++)&#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); &#125; &#125; public static int GetMid(int arr[],int left,int right)&#123; int pivot= arr[left];//取数组的第一个元素作为基数 while(left&lt;right)&#123; while(left&lt;right&amp;&amp;arr[right]&gt;=pivot)&#123; right--; //当右边的指针指向的数据大于pivot就不停向左索引，直到与left指针相遇或是索引到比pivot小的元素 &#125; arr[left]=arr[right];//将该数据放入arr[left]中; 因为arr[left]就是pivot 所以不用担心数据丢失 while(left&lt;right&amp;&amp;arr[left]&lt;=pivot)&#123; left++;//左边的指针指向的数据小于pivot就不停向右索引，直到与right指针相遇或是索引到比pivot大的元素 &#125; arr[right]=arr[left]; &#125; //回到最后，将基数插回 arr[left]=pivot; return left;//返回left，做下一次递归的边界 &#125; public static void QuickSort(int arr[],int left,int right)&#123; if(left&lt;right)&#123; int mid=GetMid(arr,left,right);//先第一次分开，并返回边界 QuickSort(arr,mid+1,right);//向右边的数组进行递归快排 QuickSort(arr,left,mid-1);//向左边的数组进行递归快排 &#125; &#125;&#125;&#125; 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案&quot;修补&quot;在一起，即分而治之)。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Arrays;import java.util.Scanner;public class MergeSort &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int array[]= &#123;8,4,5,7,1,3,6,2&#125;; int temp[] = new int[array.length]; MergeSort1(array,0,array.length-1,temp); System.out.println(Arrays.toString(array)); &#125; public static void Merge(int arr[],int left,int mid,int right,int temp[])&#123; int i=left; int j=mid+1;//右边的起点 int t=0;//指向temp数组的当前索引 while(i&lt;=mid&amp;&amp;j&lt;=right) &#123; if (arr[i] &lt;= arr[j]) &#123;//左边数组的元素小于等于右边数组的元素就将左边的元素压入右边数组 temp[t] = arr[i]; t++; i++; &#125; else &#123; temp[t] = arr[j]; t++; j++; &#125; &#125; //再将剩余的元素填充过去 while(i&lt;=mid)&#123;//左边还有剩 temp[t]=arr[i]; t++; i++; &#125; while(j&lt;=right)&#123; temp[t]=arr[j]; t++; j++; &#125; //最后将本次归并的元素合并，并不是全部合并 t=0; int lefttemp=left; while(lefttemp&lt;=right)&#123; arr[lefttemp]=temp[t]; lefttemp++; t++; &#125; &#125; public static void MergeSort1(int arr[],int left,int right,int temp[])&#123; if(left&lt;right)&#123; int mid=(left+right)/2; //向左边 MergeSort1(arr,left,mid,temp); //向右边递归 MergeSort1(arr,mid+1,right,temp); Merge(arr,left,mid,right,temp); &#125; &#125;&#125; 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"递归","slug":"递归","date":"2022-01-21T08:16:28.000Z","updated":"2022-01-21T08:21:44.691Z","comments":true,"path":"2022/01/21/递归/","link":"","permalink":"http://example.com/2022/01/21/%E9%80%92%E5%BD%92/","excerpt":"","text":"递归能解决什么样的问题 1)各种数学问题如:8皇后问题,汉诺塔,阶乘问题,迷宫问题,球和篮子的问题(google编程大赛)2)各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.3)将用栈解决的问题–&gt;递归代码比较简洁 1)执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 2)方法的局部变量是独立的，不会相互影响,比如n变量3)如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.4)递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)5)当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2022-01-18T04:42:51.000Z","updated":"2022-01-18T12:45:40.792Z","comments":true,"path":"2022/01/18/正则表达式/","link":"","permalink":"http://example.com/2022/01/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的底层实现12345String content =&quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年&quot;+ &quot;6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平&quot; + &quot;台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台&quot; + &quot;的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用于基&quot; + &quot;于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。&quot;; 目标：匹配所有四个数字 \\\\d 表示任意一个数字 1String regStr =&quot;\\\\d\\\\d\\\\d\\\\d&quot; //四个数字 创建模式对象[即正则表达式对象] 1Pattern pattern = Pattern.compile(regStr); 创建匹配器 1Matcher matcher = pattern.matcher(content); 开始匹配 123 while(matcher.find())&#123; System.out.println(&quot;找到: &quot;+ matcher.group(0));&#125; 效果图 底层原理matcher.find()的作用 根据指定的规则，定位满足条件的子字符串(比如1998) 找到后将，子字符串的索引记下，记下初始的位置到matcher对象的属性中即是 （数字1）的初始位置0 记入到 groups[0]=0; （数字8）的结束位置4 记入到 groups[1]=4; 并计入 结束位置 ‘4’ oldlast为下一次扫描做开始位置。 matcher.group(0)的作用 group的源代码 12 return GetSubSequence(groups[group+2],groups[group*2+1]).toString();&#125; 主函数内调用groups(0)，实际上在调用matcher.group(0)时，是将gourp[0]到gourp[1] [0，4）的位置进行subString（） 考虑分组情况，如 (19)(98),同理group[0]=0，先索引总的长度计入group[1]=4；第一组 (1 9)的索引计入到 group[2]=0,group[3]=2;第二组 (9 8)的索引计入到 groups[4]=2,groups[5]=4; 一些常用的符号 一道简单的应用 AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Main &#123; public static void main(String[] args) &#123; String content = &quot;&quot;; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; content = scanner.next(); int year = 0, month = 0, day = 0; String regStr = &quot;(\\\\d&#123;4&#125;)-(\\\\d&#123;2&#125;)-(\\\\d&#123;2&#125;)&quot;; Pattern pattern = Pattern.compile(regStr); Matcher matcher = pattern.matcher(content); boolean flag = false; while (matcher.find()) &#123; year = Integer.parseInt(matcher.group(1)); month = Integer.parseInt(matcher.group(2)); day = Integer.parseInt(matcher.group(3)); if (month == 1||month==3||month==5||month==7||month==8||month==10||month==12) &#123; if (day &gt;= 1 &amp;&amp; day &lt;= 31) &#123; flag = true; break; &#125; &#125; else if (month == 2) &#123; if (isLeepyear(year)) &#123; if (day &gt;= 1 &amp;&amp; day &lt;= 29) &#123; flag = true; &#125; &#125; else&#123; if(day&gt;=1&amp;&amp;day&lt;=28) flag=true; &#125; &#125; else if(month==4||month==6||month==9||month==11)&#123; if(day&gt;=1&amp;&amp;day&lt;=30)&#123; flag=true; &#125; &#125; else&#123; flag=false; &#125; &#125; if(flag)&#123; System.out.println(&quot;yes&quot;); &#125; else&#123; System.out.println(&quot;no&quot;); &#125; &#125; &#125; public static boolean isLeepyear(int year) &#123; return year % 4== 0 &amp;&amp; year%100!=0||year%400==0; &#125;&#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"栈","slug":"栈","date":"2022-01-17T05:42:44.000Z","updated":"2022-01-21T08:16:15.334Z","comments":true,"path":"2022/01/17/栈/","link":"","permalink":"http://example.com/2022/01/17/%E6%A0%88/","excerpt":"","text":"Quick Start创建栈实现栈的思路分析1.使用数组模拟栈2.定义一个变量TOP来表示栈顶，初始化为-13.入栈的操作，当有数据加入到栈时，top++;stack{top}=data;4.出栈的操作，int value=stack[–top];return value; java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.Scanner;public class ArrStackDemo &#123; public static void main(String[] args) &#123; ArrayStack stack = new ArrayStack(3); Scanner scanner = new Scanner(System.in); char key=&#x27; &#x27;; boolean loop=true; while(loop) &#123; System.out.printf(&quot;l(List):显示栈\\n&quot;); System.out.printf(&quot;e(exit):退出\\n&quot;); System.out.printf(&quot;p(push):入栈\\n&quot;); System.out.printf(&quot;o(pop):出栈\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case&#x27;l&#x27;: stack.list(); break; case&#x27;e&#x27;: scanner.close(); loop=false; break; case&#x27;p&#x27;: System.out.println(&quot;请输入一个数据&quot;); int value=scanner.nextInt(); stack.push(value); break; case&#x27;o&#x27;: try &#123; int res=stack.pop(); System.out.printf(&quot;出栈的数据为:%d\\n&quot;,res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; &#125; &#125; System.out.println(&quot;退出\\n&quot;); &#125; &#125;class ArrayStack&#123; private int maxSize;//栈的大小 private int[] stack;//用数组模拟栈 private int top=-1;//表示栈顶，初始化为-1 public ArrayStack(int maxSize) &#123; this.maxSize=maxSize; stack=new int[maxSize]; &#125; //栈满 public boolean isFull() &#123; return top==maxSize-1; &#125; //栈空 public boolean isEmpty() &#123; return top==-1; &#125; public void push(int value) &#123; if(isFull()) &#123; System.out.printf(&quot;栈满，无法继续存放\\n&quot;); return; &#125; top++; stack[top]=value; &#125; public int pop() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;栈为空，无法取得数据\\n&quot;); &#125;else &#123; return stack[top--]; &#125; &#125; //显示栈的情况[遍历栈],从栈顶开始; public void list() &#123; if(isEmpty()) &#123; System.out.println(&quot;栈空，无法获取数据&quot;); return; &#125; for(int i=top;i&gt;=0;i--) &#123; System.out.printf(&quot;Stack[%d]=%d\\n&quot;,i,stack[i]); &#125; &#125;&#125; 程序测试 简单的中缀计算器①在一个创建好的栈的基础上先提供方法(①查看栈顶②计算方法③比较运算符优先级)②创建两个栈，存放数据和存放符号③在Main函数内用一个辅助变量index去索引整个表达式 判断几种情况 一 若index所指向的变量是运算符则 ①如果oper栈不为空，则先与oper栈顶的运算符比较，若小于等于栈顶的运算符，则在数栈内弹出两个数字在符号栈弹出一个符号进行运算，然后再将符号压入栈中 ②若oper栈为空，则符号直接入栈 二 若index所指向的变量是数字 ①判断数字有几位，然后直接压入栈中 ④ 最后存放在数字栈中的即是结果 java版本代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; ArrayStack numstack = new ArrayStack(10); ArrayStack operstack = new ArrayStack(10); String expression = &quot;7*2*2-5+1-5+3-4&quot;; Scanner scanner = new Scanner(System.in); int index=0; int num1=0;int num2=0;int oper=0;int res=0; char ch=&#x27; &#x27;; String keepNum=&quot;&quot;; while(true)&#123; ch= expression.substring(index,index+1).charAt(0); if(operstack.isOper(ch))&#123; if(!operstack.isEmpty())&#123; if(operstack.priority(ch)&lt;=operstack.priority(operstack.peek())) &#123; num1 = numstack.pop(); num2 = numstack.pop(); oper = operstack.pop(); res = numstack.cal(num1, num2, oper); System.out.printf(&quot;%d\\n&quot;,res); numstack.push(res); operstack.push(ch); &#125;else&#123; operstack.push(ch); &#125; &#125;else&#123; operstack.push(ch); &#125; &#125;else&#123; keepNum+=ch; if(index==expression.length()-1) &#123; numstack.push(Integer.parseInt(keepNum)); &#125;else&#123; if(operstack.isOper(expression.substring(index+1,index+2).charAt(0)))&#123; numstack.push(Integer.parseInt(keepNum)); keepNum=&quot;&quot;; &#125; &#125; &#125; index++; if(index&gt;=expression.length())&#123; break; &#125; &#125; while(true)&#123; numstack.list(); if(operstack.isEmpty())&#123; break; &#125; num1 = numstack.pop(); num2 = numstack.pop(); oper = operstack.pop(); if(!operstack.isEmpty()) &#123; if(operstack.peek()==oper&amp;&amp;oper==&#x27;-&#x27;) &#123; num1 = num1 * -1; &#125; &#125; res = numstack.cal(num1, num2, oper); numstack.push(res); &#125; System.out.printf(&quot;表达式%s = %d\\n&quot;,expression,numstack.pop()); &#125;&#125;class ArrayStack&#123; private int maxSize;//栈的大小 private int[] stack;//用数组模拟栈 private int top=-1;//表示栈顶，初始化为-1 public ArrayStack(int maxSize) &#123; this.maxSize=maxSize; stack=new int[maxSize]; &#125; //栈满 public boolean isFull() &#123; return top==maxSize-1; &#125; //栈空 public boolean isEmpty() &#123; return top==-1; &#125; public void push(int value) &#123; if(isFull()) &#123; System.out.printf(&quot;栈满，无法继续存放\\n&quot;); return; &#125; top++; stack[top]=value; &#125; public int pop() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;栈为空，无法取得数据\\n&quot;); &#125;else &#123; return stack[top--]; &#125; &#125; //显示栈的情况[遍历栈],从栈顶开始; public void list() &#123; if(isEmpty()) &#123; System.out.println(&quot;栈空，无法获取数据&quot;); return; &#125; for(int i=top;i&gt;=0;i--) &#123; System.out.printf(&quot;Stack[%d]=%d\\n&quot;, i, stack[i]); &#125; &#125; public int priority(int oper)&#123; if(oper==&#x27;*&#x27;||oper==&#x27;/&#x27;)&#123; return 1; &#125; else if(oper==&#x27;+&#x27;||oper==&#x27;-&#x27;)&#123; return 0; &#125; else&#123; return -1; &#125; &#125; public boolean isOper(int oper)&#123; return oper==&#x27;+&#x27;||oper==&#x27;-&#x27;||oper==&#x27;*&#x27;||oper==&#x27;/&#x27;; &#125; public int cal(int num1,int num2,int oper)&#123; int res=0; switch(oper)&#123; case &#x27;+&#x27;: res=num1+num2; break; case &#x27;-&#x27;: res=num2-num1; break; case &#x27;*&#x27;: res=num1*num2; break; case &#x27;/&#x27;: res=num2/num1; break; &#125; return res; &#125; public int peek()&#123; return stack[top]; &#125;&#125; 中缀表达式转后缀表达式 思路分析 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 import java.util.ArrayList;import java.util.List;import java.util.Scanner;import java.util.Stack;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String str=scanner.nextLine(); str=str.substring(0,str.length()-1); List&lt;String&gt; list = toList(str); List&lt;String&gt; res=changeList(list); for(String ee:res)&#123; System.out.printf(ee); &#125; System.out.println(); &#125; &#125; public static List&lt;String&gt; toList(String str)&#123; //将表达式压入数组,比较好处理 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i=0;char ch;String te; for(;i&lt;str.length();)&#123; if((ch=str.charAt(i))&gt;57||(ch=str.charAt(i))&lt;48)&#123; //若是符号则直接进入List list.add(&quot;&quot;+ch); i++; &#125; else&#123; te=&quot;&quot;; while(i&lt;str.length()&amp;&amp;(ch=str.charAt(i))&gt;=48&amp;&amp;(ch=str.charAt(i))&lt;=57)&#123; 若是数或者是多位数，则进行拼接 te+=ch; i++;//拼接 &#125; list.add(te); 将拼接完的数压入数组 &#125; &#125; return list; &#125; public static List&lt;String&gt; changeList(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); for(String ee:list)&#123; if(ee.matches(&quot;\\\\d+&quot;))&#123; 若正则表达式匹配的是数,则直接入数组 list1.add(ee); &#125; else if(ee.equals(&quot;(&quot;))&#123; stack.push(ee); //若是左括号,则直接压入栈中 &#125; else if(ee.equals(&quot;)&quot;))&#123; while(!stack.peek().equals(&quot;(&quot;))&#123; //若是右括号，则 栈中数据全部压入数组，直到栈空或者匹配到左括号 list1.add(stack.pop()); &#125; stack.pop(); 匹配到左括号，退出循环，并将栈顶的左括号弹出 &#125; else&#123; while(stack.size()!=0&amp;&amp;Op.getvalue(stack.peek())&gt;= Op.getvalue(ee))&#123; 若是ee是运算符 则 运算符比较，若栈顶的运算符优先级比现在(ee)的大，则将栈中数据全部压入数组，直到运栈空或者优先级比ee小 list1.add(stack.pop()); &#125; stack.push(ee); 将ee压入栈中 &#125; &#125; while(stack.size()!=0)&#123; 如果栈中还有数据，则将栈中全部数据压入数组 list1.add(stack.pop()); &#125;return list1; &#125;&#125;class Op&#123; public static int ADD =1; public static int MUL =2; public static int DIV =2; public static int SUB=1; public static int getvalue(String op)&#123; int res=0; if(op.equals(&quot;+&quot;))&#123; res=ADD; &#125; else if(op.equals(&quot;-&quot;))&#123; res=SUB; &#125; else if(op.equals(&quot;*&quot;))&#123; res=MUL; &#125; else if(op.equals(&quot;/&quot;))&#123; res=DIV; &#125; return res; &#125;;&#125;&#125; 后缀表达式运算 思路分析 将一个顺序表中的数据用for循环增强依次取出,若是数则直接压入栈中，若是运算符，则直接弹出两个数与该运算符进行运算 [OJ][1508]中缀表达式转后缀表达式并运算 [JAVA] 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127 import java.util.ArrayList;import java.util.List;import java.util.Scanner;import java.util.Stack;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String str=scanner.next(); str=str.substring(0,str.length()-1); List&lt;String&gt; list = toList(str); List&lt;String&gt; res=changeList(list); int n=cal(res); for(String ee:res)&#123; System.out.printf(ee); &#125; System.out.println(); System.out.printf(&quot;结果为:%d\\n&quot;,n); &#125; &#125; public static List&lt;String&gt; toList(String str)&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i=0;char ch;String te; do&#123; if((ch=str.charAt(i))&gt;57||(ch=str.charAt(i))&lt;48)&#123; list.add(&quot;&quot;+ch); i++; &#125; else&#123; te=&quot;&quot;; while(i&lt;str.length()&amp;&amp;(ch=str.charAt(i))&gt;=48&amp;&amp;(ch=str.charAt(i))&lt;=57)&#123; te+=ch; i++; &#125; list.add(te); &#125; &#125;while(i&lt;str.length()); return list; &#125; public static List&lt;String&gt; changeList(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); for(String ee:list)&#123; if(ee.matches(&quot;\\\\d+&quot;))&#123; list1.add(ee); &#125; else if(ee.equals(&quot;(&quot;))&#123; stack.push(ee); &#125; else if(ee.equals(&quot;)&quot;))&#123; while(!stack.peek().equals(&quot;(&quot;))&#123; list1.add(stack.pop()); &#125; stack.pop(); &#125; else&#123; while(stack.size()!=0&amp;&amp;Op.getvalue(stack.peek())&gt;= Op.getvalue(ee))&#123; list1.add(stack.pop()); &#125; stack.push(ee); &#125; &#125; while(stack.size()!=0)&#123; list1.add(stack.pop()); &#125;return list1; &#125; public static int cal(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack =new Stack&lt;String&gt;(); for(String ee:list)&#123; if(ee.matches(&quot;\\\\d+&quot;))&#123; stack.push(ee); &#125; else&#123; int num2=Integer.parseInt(stack.pop()); int num1=Integer.parseInt(stack.pop()); int res=0; if(ee.equals(&quot;+&quot;))&#123; res=num2+num1; &#125; else if(ee.equals(&quot;-&quot;))&#123; res=num1-num2; &#125; else if(ee.equals(&quot;*&quot;))&#123; res=num1*num2; &#125; else if(ee.equals(&quot;/&quot;))&#123; res=num1/num2; &#125; stack.push(&quot;&quot;+res); &#125; &#125; return Integer.parseInt(stack.pop()); &#125;&#125;class Op&#123; public static int ADD =1; public static int MUL =2; public static int DIV =2; public static int SUB=1; public static int getvalue(String op)&#123; int res=0; if(op.equals(&quot;+&quot;))&#123; res=ADD; &#125; else if(op.equals(&quot;-&quot;))&#123; res=SUB; &#125; else if(op.equals(&quot;*&quot;))&#123; res=MUL; &#125; else if(op.equals(&quot;/&quot;))&#123; res=DIV; &#125; return res; &#125;;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"链表","slug":"链表","date":"2022-01-16T11:56:16.000Z","updated":"2022-01-16T12:27:53.361Z","comments":true,"path":"2022/01/16/链表/","link":"","permalink":"http://example.com/2022/01/16/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"Quick Start链表是一种物理存储单元上非连续、非顺序的存储结构，由一个或多个结点组成，节点可分为数据域与指针域。链表在插入数据时的复杂度比线性表和顺序表低很多，因此当一组很庞大数据需要管理时，采用链表可以大大增加计算机效率。 本文介绍两种类型的链表 ① 单向链表 ② 环状链表 单向链表单向链表只需每次用辅助指针将链表遍历至最后一个节点，再将最后一个节点的指针域指向要插入的节点即可。或是用头插法，双指针法都可以。 java版本代码实现简单的单向链表的增删添改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package Main;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; HeroNode hero1 = new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;); HeroNode hero2 = new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;); HeroNode hero3 = new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;); HeroNode hero4 = new HeroNode(3,&quot;小卢&quot;,&quot;玉麒麟&quot;); SingleLinkedlist single = new SingleLinkedlist(); single.addByorder(hero2);single.addByorder(hero1);single.addByorder(hero3); single.list(); single.Del(2); System.out.printf(&quot;-----删除后-----------\\n&quot;); single.list(); System.out.printf(&quot;-----修改后-----------\\n&quot;); single.modify(hero4); single.list(); &#125;&#125;class HeroNode&#123; public int no; public String name; public String nickname; public HeroNode next; public HeroNode(int Hno,String Hname,String Hnickname) &#123; //构造器 this.no=Hno; this.name=Hname; this.nickname=Hnickname; &#125; @Override public String toString() &#123; return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;; &#125;&#125;class SingleLinkedlist&#123; private HeroNode head= new HeroNode(0,&quot;&quot;,&quot;&quot;); public void add(HeroNode node) &#123; HeroNode cur=head; while(true) &#123; if(cur.next==null) &#123;//遍历到最后一个 break; &#125; cur=cur.next; &#125; cur.next=node; //将新的Node结点插入进去 &#125; public void list() &#123; HeroNode cur=head.next; if(head.next==null) &#123; System.out.printf(&quot;链表为空&quot;); return; &#125; while(cur!=null) &#123; System.out.println(cur); cur=cur.next; &#125; &#125; public void addByorder(HeroNode node) &#123; if(head.next==null) &#123; //第一种情况，如果没有结点 那node就为第一个结点 head.next=node; return; &#125; else if(head.next.no&gt;node.no) &#123; 第二种情况 若node结点的num值比第一个结点的还小 node.next=head.next; head.next=node; return; &#125; else &#123; HeroNode cur=head,pre = null; while(cur!=null) &#123; if(cur.no&gt;node.no) &#123; //第三种，插入在中间和最后一个 break; &#125; pre=cur; cur=cur.next; &#125; node.next=cur; pre.next=node; return; &#125; &#125; public void Del(int no) &#123; //按照序号来找即可 if(head.next==null) &#123; System.out.printf(&quot;链表不存在\\n&quot;); return; &#125; HeroNode cur=head.next; boolean flag=false; while(cur!=null) &#123; if(cur.next.no==no) &#123; //这里必须是cur的下一个结点的值 flag=true; break; &#125; cur=cur.next; &#125; if(flag) &#123; cur.next=cur.next.next; return; &#125; else &#123; System.out.printf(&quot;不存在该节点\\n&quot;); return; &#125; &#125; public void modify(HeroNode node) &#123; if(head.next==null) &#123; System.out.printf(&quot;链表不存在\\n&quot;); return; &#125; HeroNode cur=head.next; boolean flag=false; while(cur!=null) &#123; if(cur.no==node.no) &#123; flag=true; break; &#125; cur=cur.next; &#125; if(flag) &#123; cur.name=node.name; cur.nickname=node.nickname; return; &#125; else &#123; System.out.printf(&quot;不存在该节点\\n&quot;); return; &#125; &#125; &#125; 效果图 环形链表环形链表通过 一个辅助指针（first）指向链表的第一个结点，再通过一个cur指针遍历链表，之后将cur指向的结点的next域指向first 形成环状 java版本代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package Main;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); CircleSingleLinkedList circle = new CircleSingleLinkedList(); circle.addBoy(5); circle.list(); &#125; &#125;class CircleSingleLinkedList&#123; private Boy first =new Boy(-1); public void addBoy(int nums) &#123; if(nums&lt;1) &#123; System.out.printf(&quot;数据错误\\n&quot;); return; &#125; Boy curBoy=null;//辅助指针 for(int i=1;i&lt;=nums;i++) &#123; Boy boy=new Boy(i); if(i==1) &#123; //如果是第一个 就交代first指针与cur指针 first=boy; first.setNext(first); curBoy=first; &#125;else &#123; curBoy.setNext(boy); //cur依次向后移，但是first始终不变 boy.setNext(first); //这步是为了连成环状 curBoy=boy; &#125; &#125; &#125; public void list() &#123; if(first==null) &#123; System.out.printf(&quot;链表为空，没有数据\\n&quot;); return; &#125; Boy cur=first; while(cur!=null) &#123; if(cur.getNext()==first) &#123; System.out.printf(&quot;%d\\n&quot;,cur.getNo()); break; &#125; else &#123; System.out.printf(&quot;%d-&gt;&quot;,cur.getNo()); &#125; cur=cur.getNext(); &#125; &#125; &#125;class Boy&#123; private int no; private Boy next; public Boy(int no) &#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125; 约瑟夫环 具体思路 java代码（老版本oj能AC,不知道为什么新平台一直提示scanner错误） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); CircleSingleLinkedList circle = new CircleSingleLinkedList(); while(scanner.hasNext()) &#123; int Case=0; int data[]=new int[100]; int T=scanner.nextInt(),i; for(i=0;i&lt;T;i++) &#123; int n,m; Case++; n=scanner.nextInt(); m=scanner.nextInt(); circle.addBoy(n); for(int j=0;j&lt;n;j++) &#123; data[j]=scanner.nextInt(); &#125; System.out.printf(&quot;Case %d:&quot;,Case); circle.countBoy(1,m,n,data); &#125; &#125; scanner.close();&#125; &#125;class CircleSingleLinkedList&#123; private Boy first =new Boy(-1); public void addBoy(int nums) &#123; if(nums&lt;1) &#123; System.out.printf(&quot;数据错误\\n&quot;); return; &#125; Boy curBoy=null; for(int i=1;i&lt;=nums;i++) &#123; Boy boy=new Boy(i); if(i==1) &#123; first=boy; first.setNext(first); curBoy=first; &#125;else &#123; curBoy.setNext(boy); boy.setNext(first); curBoy=boy; &#125; &#125; &#125; public void list() &#123; if(first==null) &#123; System.out.printf(&quot;链表为空，没有数据\\n&quot;); return; &#125; Boy cur=first; while(cur!=null) &#123; if(cur.getNext()==first) &#123; System.out.printf(&quot;%d\\n&quot;,cur.getNo()); break; &#125; else &#123; System.out.printf(&quot;%d-&gt;&quot;,cur.getNo()); &#125; cur=cur.getNext(); &#125; &#125; public void countBoy(int startNo,int countNum,int nums,int data[]) &#123; if(first==null||startNo&lt;1||startNo&gt;nums) &#123; System.out.printf(&quot;参数错误&quot;); return; &#125; Boy helper = first; while(true) &#123; if(helper.getNext()==first) &#123; break; &#125; helper=helper.getNext(); &#125; for(int j=0;j&lt;startNo-1;j++) &#123; 先指到开始的位置 first=first.getNext(); helper=helper.getNext(); &#125; while(true) &#123; if(helper==first) &#123; break; &#125; for(int j=0;j&lt;countNum-1;j++) &#123; //移动几次 first=first.getNext(); helper=helper.getNext(); &#125; System.out.printf(&quot;%d-&gt;&quot;,first.getNo()); countNum=data[first.getNo()-1]; first=first.getNext(); helper.setNext(first); &#125; System.out.printf(&quot;%d\\n&quot;,first.getNo()); &#125; &#125;class Boy&#123; private int no; private Boy next; public Boy(int no) &#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"队列","slug":"ceshi","date":"2022-01-14T12:49:31.123Z","updated":"2022-01-14T12:57:57.360Z","comments":true,"path":"2022/01/14/ceshi/","link":"","permalink":"http://example.com/2022/01/14/ceshi/","excerpt":"","text":"队列是一种线型的结构，与栈不同，队列的数据是先进先出。##数组单向队列 单向队列只能使用一次，即达到最大容量后无法继续增添删改，由Maxsize（最大容量），rear（队列尾）和front（队列头）三个变量进行数据的进队和出队 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129$ public class Main&#123; public static void main(String[] args) &#123; // ArrayQueue arrayQueue = new ArrayQueue(3); char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125;class ArrayQueue&#123; private int maxSize; private int front; private int rear; private int[] arr; //创建队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize=arrMaxSize; arr=new int[maxSize]; front =-1;//指向队列的头部，分析出front是队列头的前一个位置 rear=-1;//指向队列尾，指向队列尾的数据 &#125; //判断队列是否满 public boolean isFull() &#123; return rear==maxSize-1; &#125; public boolean isEmpty() &#123; return rear==front; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if(isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; rear++;//让rear后移 arr[rear]=n; &#125; //出队列 public int getQueue() &#123; if(isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; front++;//后移到第一个 return arr[front]; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; for(int i=0;i&lt;arr.length;i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i, arr[i]); &#125; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front+1]; &#125;&#125; ##环形队列 与单向队列不同，环形队列可以多次反复的使用，其原因是rear与front指针在指向下一个数组位置是都要对maxsize进行取余 因此可以反复使用 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127$ public class Main&#123; public static void main(String[] args) &#123; System.out.printf(&quot;测试数组环形队列~~~\\n&quot;); CircleArray arrayQueue = new CircleArray(4); // 设置为4，实则为3 //因为预留了一个位置 char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125; class CircleArray &#123; private int maxSize; private int front; private int rear; private int[] arr; public CircleArray(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; public boolean isEmpty() &#123; return front == rear; &#125; public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; arr[rear] = n; rear = (rear + 1) % maxSize; //将rear后移，这里必须考虑取模，可能是一圈两圈 n圈 &#125; public int getQueue() &#123; if (isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; int val = arr[front]; front = (front + 1) % maxSize; return val; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; //思路 从front开始遍历，遍历多少个元素 //遍历整个数组数据，(rear+maxSize-front)%maxsize for(int i=0;i&lt;front+size();i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i%maxSize, arr[i%maxSize]); &#125; &#125; public int size() &#123; return (rear+maxSize-front)%maxSize; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front]; &#125; &#125; ##学校的OJ题 此题只需将 0-k-1 的数据入队，再将k-m的数据输出，再将 0-K-1的数据出队即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) &#123; int m,n,i; m=scanner.nextInt(); n=scanner.nextInt(); if(m==0&amp;&amp;n==0) break; int data[]=new int[m+1]; queue Queue = new queue(m); for(i=0;i&lt;m;i++) &#123; data[i]=scanner.nextInt(); &#125; for(i=0;i&lt;n;i++) &#123; Queue.add(data[i]); &#125; for(;i&lt;m;i++) &#123; System.out.printf(&quot;%d &quot;,data[i]); &#125; for(i=0;i&lt;n;i++) &#123; int res=Queue.getqueue(); if(i==n-1) System.out.printf(&quot;%d\\n&quot;,res); else System.out.printf(&quot;%d &quot;,res); &#125; &#125; &#125; &#125;class queue&#123; Scanner scanner =new Scanner(System.in); private int rear; private int front; private int Maxsize; private int[] arr; public queue(int maxsize) &#123; Maxsize=maxsize; arr=new int[Maxsize]; rear=-1; front=-1; &#125; public void add(int n) &#123; arr[++rear]=n; &#125; public int getqueue() &#123; return arr[++front]; &#125; &#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-01-13T13:36:50.434Z","updated":"2022-01-14T08:39:47.842Z","comments":true,"path":"2022/01/13/hello-world/","link":"","permalink":"http://example.com/2022/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}],"categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}