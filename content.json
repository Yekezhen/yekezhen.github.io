{"meta":{"title":"欢迎来到我的个人博客","subtitle":"","description":"","author":"Yekezhen","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-01-14T03:55:17.000Z","updated":"2022-01-14T03:56:40.162Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"文章归档","date":"2022-01-14T04:06:23.570Z","updated":"2022-01-14T03:59:14.282Z","comments":true,"path":"archive.html","permalink":"http://example.com/archive.html","excerpt":"","text":""}],"posts":[{"title":"哈希表","slug":"哈希表","date":"2022-01-25T15:34:54.000Z","updated":"2022-01-25T15:42:20.021Z","comments":true,"path":"2022/01/25/哈希表/","link":"","permalink":"http://example.com/2022/01/25/%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"","text":"散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 哈希表是 通过对象数组+链表实现的，比对象数组稍微麻烦一些 底层代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import java.util.Scanner;public class HashTableTest &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); HashTab hashTab= new HashTab(7); String key=&quot;&quot;; while(true)&#123; System.out.println(&quot;[list],输出哈希表&quot;); System.out.println(&quot;[add],添加数据&quot;); System.out.println(&quot;[exit],退出&quot;); System.out.println(&quot;[find],查找数据&quot;); System.out.println(&quot;[del],删除数据&quot;); key=scanner.next(); switch (key)&#123; case &quot;list&quot;: hashTab.list(); break; case &quot;add&quot;: System.out.println(&quot;请输入id&quot;); int num=scanner.nextInt(); System.out.println(&quot;请输入姓名&quot;); String name=scanner.next(); Emp emp = new Emp(num,name); hashTab.add(emp); break; case &quot;exit&quot;: scanner.close(); System.exit(0); break; case &quot;del&quot;: System.out.println(&quot;请输入ID&quot;); num=scanner.nextInt(); hashTab.Del(num); break; case &quot;find&quot;: System.out.println(&quot;请输入ID&quot;); num=scanner.nextInt(); hashTab.Find(num); break; &#125; &#125; &#125;&#125;class Emp&#123; public int id; public String name; public Emp next; public Emp(int id, String name) &#123; this.id = id; this.name = name; &#125;&#125;class EmpLinkedList&#123; private Emp head; public void add(Emp node)&#123; if(head==null)&#123; head=node; return; &#125; if(node.id&lt; head.id)&#123; node.next=head; head=node; return; &#125; else&#123; Emp cur=head,pre=null; while(cur!=null)&#123; if(cur.id&gt;node.id)&#123; break; &#125; pre=cur; cur=cur.next; &#125; node.next=cur; pre.next=node; &#125; &#125; public void list(int id)&#123; if(head==null)&#123; System.out.println(&quot;当前&quot;+id+&quot;号链表为空&quot;); &#125; else&#123; System.out.printf(&quot;当前&quot;+id+&quot;号链表的信息为 &quot;); Emp cur=head; while(cur!=null)&#123; System.out.printf(&quot;=&gt; id = %d,name = %s &quot;,cur.id,cur.name); cur=cur.next; &#125; System.out.println(); &#125; &#125; public Emp Search(int id)&#123; if(head==null)&#123; System.out.println(&quot;链表为空&quot;); return null; &#125; Emp cur=head; while(cur!=null)&#123; if(cur.id==id)&#123; break; &#125; cur=cur.next; &#125; if(cur==null)&#123; System.out.println(&quot;链表为空&quot;); return null; &#125; return cur; &#125; public Emp Del(int id)&#123; if(head==null)&#123; System.out.println(&quot;删除失败链表为空&quot;); return null; &#125; if(head.next==null)&#123; return head=null; &#125; Emp cur=head; while(cur.next!=null)&#123; if(cur.next.id==id)&#123; break; &#125; cur=cur.next; &#125; cur.next=cur.next.next; return cur; &#125;&#125;class HashTab&#123; private EmpLinkedList[] empLinkedListArray; private int size; public HashTab(int size)&#123; this.size=size; empLinkedListArray = new EmpLinkedList[size]; for(int i=0;i&lt;size;i++)&#123; empLinkedListArray[i]= new EmpLinkedList(); &#125; &#125; public void add(Emp node)&#123; int empLinkedlistNo = GetQueue(node.id); empLinkedListArray[empLinkedlistNo].add(node); &#125; public int GetQueue(int num)&#123; return num%size; &#125; public void list()&#123; for(int i=0;i&lt;size;i++)&#123; empLinkedListArray[i].list(i+1); &#125; &#125; public void Find(int id)&#123; int num=GetQueue(id); Emp node =empLinkedListArray[num].Search(id); if(node!=null)&#123; System.out.printf(&quot;数据%d在第%d条中\\n&quot;,node.id,num+1); &#125; else&#123; System.out.println(&quot;未找到数据&quot;); &#125; &#125; public void Del(int id)&#123; int num=GetQueue(id); Emp node= empLinkedListArray[num].Del(id); if(node!=null)&#123; System.out.printf(&quot;数据%d在第%d条中已经删除\\n&quot;,node.id,num+1); &#125; else&#123; System.out.println(&quot;未找到数据||删除成功&quot;); &#125; &#125;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"排序","slug":"排序","date":"2022-01-22T07:54:31.000Z","updated":"2022-01-25T15:35:54.946Z","comments":true,"path":"2022/01/22/排序/","link":"","permalink":"http://example.com/2022/01/22/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"快速排序 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 时间复杂度为 O(nlogn) 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 import java.util.Scanner;public class QuickSort &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; int n=scanner.nextInt(); int arr[] = new int[n]; for(int i=0;i&lt;n;i++)&#123; arr[i]=scanner.nextInt(); &#125; QuickSort(arr,0,arr.length-1); for(int i=0;i&lt;n;i++)&#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); &#125; &#125; public static int GetMid(int arr[],int left,int right)&#123; int pivot= arr[left];//取数组的第一个元素作为基数 while(left&lt;right)&#123; while(left&lt;right&amp;&amp;arr[right]&gt;=pivot)&#123; right--; //当右边的指针指向的数据大于pivot就不停向左索引，直到与left指针相遇或是索引到比pivot小的元素 &#125; arr[left]=arr[right];//将该数据放入arr[left]中; 因为arr[left]就是pivot 所以不用担心数据丢失 while(left&lt;right&amp;&amp;arr[left]&lt;=pivot)&#123; left++;//左边的指针指向的数据小于pivot就不停向右索引，直到与right指针相遇或是索引到比pivot大的元素 &#125; arr[right]=arr[left]; &#125; //回到最后，将基数插回 arr[left]=pivot; return left;//返回left，做下一次递归的边界 &#125; public static void QuickSort(int arr[],int left,int right)&#123; if(left&lt;right)&#123; int mid=GetMid(arr,left,right);//先第一次分开，并返回边界 QuickSort(arr,mid+1,right);//向右边的数组进行递归快排 QuickSort(arr,left,mid-1);//向左边的数组进行递归快排 &#125; &#125;&#125;&#125; 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案&quot;修补&quot;在一起，即分而治之)。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Arrays;import java.util.Scanner;public class MergeSort &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int array[]= &#123;8,4,5,7,1,3,6,2&#125;; int temp[] = new int[array.length]; MergeSort1(array,0,array.length-1,temp); System.out.println(Arrays.toString(array)); &#125; public static void Merge(int arr[],int left,int mid,int right,int temp[])&#123; int i=left; int j=mid+1;//右边的起点 int t=0;//指向temp数组的当前索引 while(i&lt;=mid&amp;&amp;j&lt;=right) &#123; if (arr[i] &lt;= arr[j]) &#123;//左边数组的元素小于等于右边数组的元素就将左边的元素压入右边数组 temp[t] = arr[i]; t++; i++; &#125; else &#123; temp[t] = arr[j]; t++; j++; &#125; &#125; //再将剩余的元素填充过去 while(i&lt;=mid)&#123;//左边还有剩 temp[t]=arr[i]; t++; i++; &#125; while(j&lt;=right)&#123; temp[t]=arr[j]; t++; j++; &#125; //最后将本次归并的元素合并，并不是全部合并 t=0; int lefttemp=left; while(lefttemp&lt;=right)&#123; arr[lefttemp]=temp[t]; lefttemp++; t++; &#125; &#125; public static void MergeSort1(int arr[],int left,int right,int temp[])&#123; if(left&lt;right)&#123; int mid=(left+right)/2; //向左边 MergeSort1(arr,left,mid,temp); //向右边递归 MergeSort1(arr,mid+1,right,temp); Merge(arr,left,mid,right,temp); &#125; &#125;&#125; 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"递归","slug":"递归","date":"2022-01-21T08:16:28.000Z","updated":"2022-01-21T08:21:44.691Z","comments":true,"path":"2022/01/21/递归/","link":"","permalink":"http://example.com/2022/01/21/%E9%80%92%E5%BD%92/","excerpt":"","text":"递归能解决什么样的问题 1)各种数学问题如:8皇后问题,汉诺塔,阶乘问题,迷宫问题,球和篮子的问题(google编程大赛)2)各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.3)将用栈解决的问题–&gt;递归代码比较简洁 1)执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 2)方法的局部变量是独立的，不会相互影响,比如n变量3)如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.4)递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)5)当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2022-01-18T04:42:51.000Z","updated":"2022-01-18T12:45:40.792Z","comments":true,"path":"2022/01/18/正则表达式/","link":"","permalink":"http://example.com/2022/01/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的底层实现12345String content =&quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年&quot;+ &quot;6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平&quot; + &quot;台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台&quot; + &quot;的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用于基&quot; + &quot;于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。&quot;; 目标：匹配所有四个数字 \\\\d 表示任意一个数字 1String regStr =&quot;\\\\d\\\\d\\\\d\\\\d&quot; //四个数字 创建模式对象[即正则表达式对象] 1Pattern pattern = Pattern.compile(regStr); 创建匹配器 1Matcher matcher = pattern.matcher(content); 开始匹配 123 while(matcher.find())&#123; System.out.println(&quot;找到: &quot;+ matcher.group(0));&#125; 效果图 底层原理matcher.find()的作用 根据指定的规则，定位满足条件的子字符串(比如1998) 找到后将，子字符串的索引记下，记下初始的位置到matcher对象的属性中即是 （数字1）的初始位置0 记入到 groups[0]=0; （数字8）的结束位置4 记入到 groups[1]=4; 并计入 结束位置 ‘4’ oldlast为下一次扫描做开始位置。 matcher.group(0)的作用 group的源代码 12 return GetSubSequence(groups[group+2],groups[group*2+1]).toString();&#125; 主函数内调用groups(0)，实际上在调用matcher.group(0)时，是将gourp[0]到gourp[1] [0，4）的位置进行subString（） 考虑分组情况，如 (19)(98),同理group[0]=0，先索引总的长度计入group[1]=4；第一组 (1 9)的索引计入到 group[2]=0,group[3]=2;第二组 (9 8)的索引计入到 groups[4]=2,groups[5]=4; 一些常用的符号 一道简单的应用 AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Main &#123; public static void main(String[] args) &#123; String content = &quot;&quot;; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; content = scanner.next(); int year = 0, month = 0, day = 0; String regStr = &quot;(\\\\d&#123;4&#125;)-(\\\\d&#123;2&#125;)-(\\\\d&#123;2&#125;)&quot;; Pattern pattern = Pattern.compile(regStr); Matcher matcher = pattern.matcher(content); boolean flag = false; while (matcher.find()) &#123; year = Integer.parseInt(matcher.group(1)); month = Integer.parseInt(matcher.group(2)); day = Integer.parseInt(matcher.group(3)); if (month == 1||month==3||month==5||month==7||month==8||month==10||month==12) &#123; if (day &gt;= 1 &amp;&amp; day &lt;= 31) &#123; flag = true; break; &#125; &#125; else if (month == 2) &#123; if (isLeepyear(year)) &#123; if (day &gt;= 1 &amp;&amp; day &lt;= 29) &#123; flag = true; &#125; &#125; else&#123; if(day&gt;=1&amp;&amp;day&lt;=28) flag=true; &#125; &#125; else if(month==4||month==6||month==9||month==11)&#123; if(day&gt;=1&amp;&amp;day&lt;=30)&#123; flag=true; &#125; &#125; else&#123; flag=false; &#125; &#125; if(flag)&#123; System.out.println(&quot;yes&quot;); &#125; else&#123; System.out.println(&quot;no&quot;); &#125; &#125; &#125; public static boolean isLeepyear(int year) &#123; return year % 4== 0 &amp;&amp; year%100!=0||year%400==0; &#125;&#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"栈","slug":"栈","date":"2022-01-17T05:42:44.000Z","updated":"2022-01-21T08:16:15.334Z","comments":true,"path":"2022/01/17/栈/","link":"","permalink":"http://example.com/2022/01/17/%E6%A0%88/","excerpt":"","text":"Quick Start创建栈实现栈的思路分析1.使用数组模拟栈2.定义一个变量TOP来表示栈顶，初始化为-13.入栈的操作，当有数据加入到栈时，top++;stack{top}=data;4.出栈的操作，int value=stack[–top];return value; java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.Scanner;public class ArrStackDemo &#123; public static void main(String[] args) &#123; ArrayStack stack = new ArrayStack(3); Scanner scanner = new Scanner(System.in); char key=&#x27; &#x27;; boolean loop=true; while(loop) &#123; System.out.printf(&quot;l(List):显示栈\\n&quot;); System.out.printf(&quot;e(exit):退出\\n&quot;); System.out.printf(&quot;p(push):入栈\\n&quot;); System.out.printf(&quot;o(pop):出栈\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case&#x27;l&#x27;: stack.list(); break; case&#x27;e&#x27;: scanner.close(); loop=false; break; case&#x27;p&#x27;: System.out.println(&quot;请输入一个数据&quot;); int value=scanner.nextInt(); stack.push(value); break; case&#x27;o&#x27;: try &#123; int res=stack.pop(); System.out.printf(&quot;出栈的数据为:%d\\n&quot;,res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; &#125; &#125; System.out.println(&quot;退出\\n&quot;); &#125; &#125;class ArrayStack&#123; private int maxSize;//栈的大小 private int[] stack;//用数组模拟栈 private int top=-1;//表示栈顶，初始化为-1 public ArrayStack(int maxSize) &#123; this.maxSize=maxSize; stack=new int[maxSize]; &#125; //栈满 public boolean isFull() &#123; return top==maxSize-1; &#125; //栈空 public boolean isEmpty() &#123; return top==-1; &#125; public void push(int value) &#123; if(isFull()) &#123; System.out.printf(&quot;栈满，无法继续存放\\n&quot;); return; &#125; top++; stack[top]=value; &#125; public int pop() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;栈为空，无法取得数据\\n&quot;); &#125;else &#123; return stack[top--]; &#125; &#125; //显示栈的情况[遍历栈],从栈顶开始; public void list() &#123; if(isEmpty()) &#123; System.out.println(&quot;栈空，无法获取数据&quot;); return; &#125; for(int i=top;i&gt;=0;i--) &#123; System.out.printf(&quot;Stack[%d]=%d\\n&quot;,i,stack[i]); &#125; &#125;&#125; 程序测试 简单的中缀计算器①在一个创建好的栈的基础上先提供方法(①查看栈顶②计算方法③比较运算符优先级)②创建两个栈，存放数据和存放符号③在Main函数内用一个辅助变量index去索引整个表达式 判断几种情况 一 若index所指向的变量是运算符则 ①如果oper栈不为空，则先与oper栈顶的运算符比较，若小于等于栈顶的运算符，则在数栈内弹出两个数字在符号栈弹出一个符号进行运算，然后再将符号压入栈中 ②若oper栈为空，则符号直接入栈 二 若index所指向的变量是数字 ①判断数字有几位，然后直接压入栈中 ④ 最后存放在数字栈中的即是结果 java版本代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; ArrayStack numstack = new ArrayStack(10); ArrayStack operstack = new ArrayStack(10); String expression = &quot;7*2*2-5+1-5+3-4&quot;; Scanner scanner = new Scanner(System.in); int index=0; int num1=0;int num2=0;int oper=0;int res=0; char ch=&#x27; &#x27;; String keepNum=&quot;&quot;; while(true)&#123; ch= expression.substring(index,index+1).charAt(0); if(operstack.isOper(ch))&#123; if(!operstack.isEmpty())&#123; if(operstack.priority(ch)&lt;=operstack.priority(operstack.peek())) &#123; num1 = numstack.pop(); num2 = numstack.pop(); oper = operstack.pop(); res = numstack.cal(num1, num2, oper); System.out.printf(&quot;%d\\n&quot;,res); numstack.push(res); operstack.push(ch); &#125;else&#123; operstack.push(ch); &#125; &#125;else&#123; operstack.push(ch); &#125; &#125;else&#123; keepNum+=ch; if(index==expression.length()-1) &#123; numstack.push(Integer.parseInt(keepNum)); &#125;else&#123; if(operstack.isOper(expression.substring(index+1,index+2).charAt(0)))&#123; numstack.push(Integer.parseInt(keepNum)); keepNum=&quot;&quot;; &#125; &#125; &#125; index++; if(index&gt;=expression.length())&#123; break; &#125; &#125; while(true)&#123; numstack.list(); if(operstack.isEmpty())&#123; break; &#125; num1 = numstack.pop(); num2 = numstack.pop(); oper = operstack.pop(); if(!operstack.isEmpty()) &#123; if(operstack.peek()==oper&amp;&amp;oper==&#x27;-&#x27;) &#123; num1 = num1 * -1; &#125; &#125; res = numstack.cal(num1, num2, oper); numstack.push(res); &#125; System.out.printf(&quot;表达式%s = %d\\n&quot;,expression,numstack.pop()); &#125;&#125;class ArrayStack&#123; private int maxSize;//栈的大小 private int[] stack;//用数组模拟栈 private int top=-1;//表示栈顶，初始化为-1 public ArrayStack(int maxSize) &#123; this.maxSize=maxSize; stack=new int[maxSize]; &#125; //栈满 public boolean isFull() &#123; return top==maxSize-1; &#125; //栈空 public boolean isEmpty() &#123; return top==-1; &#125; public void push(int value) &#123; if(isFull()) &#123; System.out.printf(&quot;栈满，无法继续存放\\n&quot;); return; &#125; top++; stack[top]=value; &#125; public int pop() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;栈为空，无法取得数据\\n&quot;); &#125;else &#123; return stack[top--]; &#125; &#125; //显示栈的情况[遍历栈],从栈顶开始; public void list() &#123; if(isEmpty()) &#123; System.out.println(&quot;栈空，无法获取数据&quot;); return; &#125; for(int i=top;i&gt;=0;i--) &#123; System.out.printf(&quot;Stack[%d]=%d\\n&quot;, i, stack[i]); &#125; &#125; public int priority(int oper)&#123; if(oper==&#x27;*&#x27;||oper==&#x27;/&#x27;)&#123; return 1; &#125; else if(oper==&#x27;+&#x27;||oper==&#x27;-&#x27;)&#123; return 0; &#125; else&#123; return -1; &#125; &#125; public boolean isOper(int oper)&#123; return oper==&#x27;+&#x27;||oper==&#x27;-&#x27;||oper==&#x27;*&#x27;||oper==&#x27;/&#x27;; &#125; public int cal(int num1,int num2,int oper)&#123; int res=0; switch(oper)&#123; case &#x27;+&#x27;: res=num1+num2; break; case &#x27;-&#x27;: res=num2-num1; break; case &#x27;*&#x27;: res=num1*num2; break; case &#x27;/&#x27;: res=num2/num1; break; &#125; return res; &#125; public int peek()&#123; return stack[top]; &#125;&#125; 中缀表达式转后缀表达式 思路分析 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 import java.util.ArrayList;import java.util.List;import java.util.Scanner;import java.util.Stack;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String str=scanner.nextLine(); str=str.substring(0,str.length()-1); List&lt;String&gt; list = toList(str); List&lt;String&gt; res=changeList(list); for(String ee:res)&#123; System.out.printf(ee); &#125; System.out.println(); &#125; &#125; public static List&lt;String&gt; toList(String str)&#123; //将表达式压入数组,比较好处理 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i=0;char ch;String te; for(;i&lt;str.length();)&#123; if((ch=str.charAt(i))&gt;57||(ch=str.charAt(i))&lt;48)&#123; //若是符号则直接进入List list.add(&quot;&quot;+ch); i++; &#125; else&#123; te=&quot;&quot;; while(i&lt;str.length()&amp;&amp;(ch=str.charAt(i))&gt;=48&amp;&amp;(ch=str.charAt(i))&lt;=57)&#123; 若是数或者是多位数，则进行拼接 te+=ch; i++;//拼接 &#125; list.add(te); 将拼接完的数压入数组 &#125; &#125; return list; &#125; public static List&lt;String&gt; changeList(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); for(String ee:list)&#123; if(ee.matches(&quot;\\\\d+&quot;))&#123; 若正则表达式匹配的是数,则直接入数组 list1.add(ee); &#125; else if(ee.equals(&quot;(&quot;))&#123; stack.push(ee); //若是左括号,则直接压入栈中 &#125; else if(ee.equals(&quot;)&quot;))&#123; while(!stack.peek().equals(&quot;(&quot;))&#123; //若是右括号，则 栈中数据全部压入数组，直到栈空或者匹配到左括号 list1.add(stack.pop()); &#125; stack.pop(); 匹配到左括号，退出循环，并将栈顶的左括号弹出 &#125; else&#123; while(stack.size()!=0&amp;&amp;Op.getvalue(stack.peek())&gt;= Op.getvalue(ee))&#123; 若是ee是运算符 则 运算符比较，若栈顶的运算符优先级比现在(ee)的大，则将栈中数据全部压入数组，直到运栈空或者优先级比ee小 list1.add(stack.pop()); &#125; stack.push(ee); 将ee压入栈中 &#125; &#125; while(stack.size()!=0)&#123; 如果栈中还有数据，则将栈中全部数据压入数组 list1.add(stack.pop()); &#125;return list1; &#125;&#125;class Op&#123; public static int ADD =1; public static int MUL =2; public static int DIV =2; public static int SUB=1; public static int getvalue(String op)&#123; int res=0; if(op.equals(&quot;+&quot;))&#123; res=ADD; &#125; else if(op.equals(&quot;-&quot;))&#123; res=SUB; &#125; else if(op.equals(&quot;*&quot;))&#123; res=MUL; &#125; else if(op.equals(&quot;/&quot;))&#123; res=DIV; &#125; return res; &#125;;&#125;&#125; 后缀表达式运算 思路分析 将一个顺序表中的数据用for循环增强依次取出,若是数则直接压入栈中，若是运算符，则直接弹出两个数与该运算符进行运算 [OJ][1508]中缀表达式转后缀表达式并运算 [JAVA] 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127 import java.util.ArrayList;import java.util.List;import java.util.Scanner;import java.util.Stack;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String str=scanner.next(); str=str.substring(0,str.length()-1); List&lt;String&gt; list = toList(str); List&lt;String&gt; res=changeList(list); int n=cal(res); for(String ee:res)&#123; System.out.printf(ee); &#125; System.out.println(); System.out.printf(&quot;结果为:%d\\n&quot;,n); &#125; &#125; public static List&lt;String&gt; toList(String str)&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i=0;char ch;String te; do&#123; if((ch=str.charAt(i))&gt;57||(ch=str.charAt(i))&lt;48)&#123; list.add(&quot;&quot;+ch); i++; &#125; else&#123; te=&quot;&quot;; while(i&lt;str.length()&amp;&amp;(ch=str.charAt(i))&gt;=48&amp;&amp;(ch=str.charAt(i))&lt;=57)&#123; te+=ch; i++; &#125; list.add(te); &#125; &#125;while(i&lt;str.length()); return list; &#125; public static List&lt;String&gt; changeList(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); for(String ee:list)&#123; if(ee.matches(&quot;\\\\d+&quot;))&#123; list1.add(ee); &#125; else if(ee.equals(&quot;(&quot;))&#123; stack.push(ee); &#125; else if(ee.equals(&quot;)&quot;))&#123; while(!stack.peek().equals(&quot;(&quot;))&#123; list1.add(stack.pop()); &#125; stack.pop(); &#125; else&#123; while(stack.size()!=0&amp;&amp;Op.getvalue(stack.peek())&gt;= Op.getvalue(ee))&#123; list1.add(stack.pop()); &#125; stack.push(ee); &#125; &#125; while(stack.size()!=0)&#123; list1.add(stack.pop()); &#125;return list1; &#125; public static int cal(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack =new Stack&lt;String&gt;(); for(String ee:list)&#123; if(ee.matches(&quot;\\\\d+&quot;))&#123; stack.push(ee); &#125; else&#123; int num2=Integer.parseInt(stack.pop()); int num1=Integer.parseInt(stack.pop()); int res=0; if(ee.equals(&quot;+&quot;))&#123; res=num2+num1; &#125; else if(ee.equals(&quot;-&quot;))&#123; res=num1-num2; &#125; else if(ee.equals(&quot;*&quot;))&#123; res=num1*num2; &#125; else if(ee.equals(&quot;/&quot;))&#123; res=num1/num2; &#125; stack.push(&quot;&quot;+res); &#125; &#125; return Integer.parseInt(stack.pop()); &#125;&#125;class Op&#123; public static int ADD =1; public static int MUL =2; public static int DIV =2; public static int SUB=1; public static int getvalue(String op)&#123; int res=0; if(op.equals(&quot;+&quot;))&#123; res=ADD; &#125; else if(op.equals(&quot;-&quot;))&#123; res=SUB; &#125; else if(op.equals(&quot;*&quot;))&#123; res=MUL; &#125; else if(op.equals(&quot;/&quot;))&#123; res=DIV; &#125; return res; &#125;;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"链表","slug":"链表","date":"2022-01-16T11:56:16.000Z","updated":"2022-01-16T12:27:53.361Z","comments":true,"path":"2022/01/16/链表/","link":"","permalink":"http://example.com/2022/01/16/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"Quick Start链表是一种物理存储单元上非连续、非顺序的存储结构，由一个或多个结点组成，节点可分为数据域与指针域。链表在插入数据时的复杂度比线性表和顺序表低很多，因此当一组很庞大数据需要管理时，采用链表可以大大增加计算机效率。 本文介绍两种类型的链表 ① 单向链表 ② 环状链表 单向链表单向链表只需每次用辅助指针将链表遍历至最后一个节点，再将最后一个节点的指针域指向要插入的节点即可。或是用头插法，双指针法都可以。 java版本代码实现简单的单向链表的增删添改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package Main;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; HeroNode hero1 = new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;); HeroNode hero2 = new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;); HeroNode hero3 = new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;); HeroNode hero4 = new HeroNode(3,&quot;小卢&quot;,&quot;玉麒麟&quot;); SingleLinkedlist single = new SingleLinkedlist(); single.addByorder(hero2);single.addByorder(hero1);single.addByorder(hero3); single.list(); single.Del(2); System.out.printf(&quot;-----删除后-----------\\n&quot;); single.list(); System.out.printf(&quot;-----修改后-----------\\n&quot;); single.modify(hero4); single.list(); &#125;&#125;class HeroNode&#123; public int no; public String name; public String nickname; public HeroNode next; public HeroNode(int Hno,String Hname,String Hnickname) &#123; //构造器 this.no=Hno; this.name=Hname; this.nickname=Hnickname; &#125; @Override public String toString() &#123; return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;; &#125;&#125;class SingleLinkedlist&#123; private HeroNode head= new HeroNode(0,&quot;&quot;,&quot;&quot;); public void add(HeroNode node) &#123; HeroNode cur=head; while(true) &#123; if(cur.next==null) &#123;//遍历到最后一个 break; &#125; cur=cur.next; &#125; cur.next=node; //将新的Node结点插入进去 &#125; public void list() &#123; HeroNode cur=head.next; if(head.next==null) &#123; System.out.printf(&quot;链表为空&quot;); return; &#125; while(cur!=null) &#123; System.out.println(cur); cur=cur.next; &#125; &#125; public void addByorder(HeroNode node) &#123; if(head.next==null) &#123; //第一种情况，如果没有结点 那node就为第一个结点 head.next=node; return; &#125; else if(head.next.no&gt;node.no) &#123; 第二种情况 若node结点的num值比第一个结点的还小 node.next=head.next; head.next=node; return; &#125; else &#123; HeroNode cur=head,pre = null; while(cur!=null) &#123; if(cur.no&gt;node.no) &#123; //第三种，插入在中间和最后一个 break; &#125; pre=cur; cur=cur.next; &#125; node.next=cur; pre.next=node; return; &#125; &#125; public void Del(int no) &#123; //按照序号来找即可 if(head.next==null) &#123; System.out.printf(&quot;链表不存在\\n&quot;); return; &#125; HeroNode cur=head.next; boolean flag=false; while(cur!=null) &#123; if(cur.next.no==no) &#123; //这里必须是cur的下一个结点的值 flag=true; break; &#125; cur=cur.next; &#125; if(flag) &#123; cur.next=cur.next.next; return; &#125; else &#123; System.out.printf(&quot;不存在该节点\\n&quot;); return; &#125; &#125; public void modify(HeroNode node) &#123; if(head.next==null) &#123; System.out.printf(&quot;链表不存在\\n&quot;); return; &#125; HeroNode cur=head.next; boolean flag=false; while(cur!=null) &#123; if(cur.no==node.no) &#123; flag=true; break; &#125; cur=cur.next; &#125; if(flag) &#123; cur.name=node.name; cur.nickname=node.nickname; return; &#125; else &#123; System.out.printf(&quot;不存在该节点\\n&quot;); return; &#125; &#125; &#125; 效果图 环形链表环形链表通过 一个辅助指针（first）指向链表的第一个结点，再通过一个cur指针遍历链表，之后将cur指向的结点的next域指向first 形成环状 java版本代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package Main;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); CircleSingleLinkedList circle = new CircleSingleLinkedList(); circle.addBoy(5); circle.list(); &#125; &#125;class CircleSingleLinkedList&#123; private Boy first =new Boy(-1); public void addBoy(int nums) &#123; if(nums&lt;1) &#123; System.out.printf(&quot;数据错误\\n&quot;); return; &#125; Boy curBoy=null;//辅助指针 for(int i=1;i&lt;=nums;i++) &#123; Boy boy=new Boy(i); if(i==1) &#123; //如果是第一个 就交代first指针与cur指针 first=boy; first.setNext(first); curBoy=first; &#125;else &#123; curBoy.setNext(boy); //cur依次向后移，但是first始终不变 boy.setNext(first); //这步是为了连成环状 curBoy=boy; &#125; &#125; &#125; public void list() &#123; if(first==null) &#123; System.out.printf(&quot;链表为空，没有数据\\n&quot;); return; &#125; Boy cur=first; while(cur!=null) &#123; if(cur.getNext()==first) &#123; System.out.printf(&quot;%d\\n&quot;,cur.getNo()); break; &#125; else &#123; System.out.printf(&quot;%d-&gt;&quot;,cur.getNo()); &#125; cur=cur.getNext(); &#125; &#125; &#125;class Boy&#123; private int no; private Boy next; public Boy(int no) &#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125; 约瑟夫环 具体思路 java代码（老版本oj能AC,不知道为什么新平台一直提示scanner错误） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); CircleSingleLinkedList circle = new CircleSingleLinkedList(); while(scanner.hasNext()) &#123; int Case=0; int data[]=new int[100]; int T=scanner.nextInt(),i; for(i=0;i&lt;T;i++) &#123; int n,m; Case++; n=scanner.nextInt(); m=scanner.nextInt(); circle.addBoy(n); for(int j=0;j&lt;n;j++) &#123; data[j]=scanner.nextInt(); &#125; System.out.printf(&quot;Case %d:&quot;,Case); circle.countBoy(1,m,n,data); &#125; &#125; scanner.close();&#125; &#125;class CircleSingleLinkedList&#123; private Boy first =new Boy(-1); public void addBoy(int nums) &#123; if(nums&lt;1) &#123; System.out.printf(&quot;数据错误\\n&quot;); return; &#125; Boy curBoy=null; for(int i=1;i&lt;=nums;i++) &#123; Boy boy=new Boy(i); if(i==1) &#123; first=boy; first.setNext(first); curBoy=first; &#125;else &#123; curBoy.setNext(boy); boy.setNext(first); curBoy=boy; &#125; &#125; &#125; public void list() &#123; if(first==null) &#123; System.out.printf(&quot;链表为空，没有数据\\n&quot;); return; &#125; Boy cur=first; while(cur!=null) &#123; if(cur.getNext()==first) &#123; System.out.printf(&quot;%d\\n&quot;,cur.getNo()); break; &#125; else &#123; System.out.printf(&quot;%d-&gt;&quot;,cur.getNo()); &#125; cur=cur.getNext(); &#125; &#125; public void countBoy(int startNo,int countNum,int nums,int data[]) &#123; if(first==null||startNo&lt;1||startNo&gt;nums) &#123; System.out.printf(&quot;参数错误&quot;); return; &#125; Boy helper = first; while(true) &#123; if(helper.getNext()==first) &#123; break; &#125; helper=helper.getNext(); &#125; for(int j=0;j&lt;startNo-1;j++) &#123; 先指到开始的位置 first=first.getNext(); helper=helper.getNext(); &#125; while(true) &#123; if(helper==first) &#123; break; &#125; for(int j=0;j&lt;countNum-1;j++) &#123; //移动几次 first=first.getNext(); helper=helper.getNext(); &#125; System.out.printf(&quot;%d-&gt;&quot;,first.getNo()); countNum=data[first.getNo()-1]; first=first.getNext(); helper.setNext(first); &#125; System.out.printf(&quot;%d\\n&quot;,first.getNo()); &#125; &#125;class Boy&#123; private int no; private Boy next; public Boy(int no) &#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"队列","slug":"ceshi","date":"2022-01-14T12:49:31.123Z","updated":"2022-01-14T12:57:57.360Z","comments":true,"path":"2022/01/14/ceshi/","link":"","permalink":"http://example.com/2022/01/14/ceshi/","excerpt":"","text":"队列是一种线型的结构，与栈不同，队列的数据是先进先出。##数组单向队列 单向队列只能使用一次，即达到最大容量后无法继续增添删改，由Maxsize（最大容量），rear（队列尾）和front（队列头）三个变量进行数据的进队和出队 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129$ public class Main&#123; public static void main(String[] args) &#123; // ArrayQueue arrayQueue = new ArrayQueue(3); char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125;class ArrayQueue&#123; private int maxSize; private int front; private int rear; private int[] arr; //创建队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize=arrMaxSize; arr=new int[maxSize]; front =-1;//指向队列的头部，分析出front是队列头的前一个位置 rear=-1;//指向队列尾，指向队列尾的数据 &#125; //判断队列是否满 public boolean isFull() &#123; return rear==maxSize-1; &#125; public boolean isEmpty() &#123; return rear==front; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if(isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; rear++;//让rear后移 arr[rear]=n; &#125; //出队列 public int getQueue() &#123; if(isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; front++;//后移到第一个 return arr[front]; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; for(int i=0;i&lt;arr.length;i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i, arr[i]); &#125; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front+1]; &#125;&#125; ##环形队列 与单向队列不同，环形队列可以多次反复的使用，其原因是rear与front指针在指向下一个数组位置是都要对maxsize进行取余 因此可以反复使用 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127$ public class Main&#123; public static void main(String[] args) &#123; System.out.printf(&quot;测试数组环形队列~~~\\n&quot;); CircleArray arrayQueue = new CircleArray(4); // 设置为4，实则为3 //因为预留了一个位置 char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125; class CircleArray &#123; private int maxSize; private int front; private int rear; private int[] arr; public CircleArray(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; public boolean isEmpty() &#123; return front == rear; &#125; public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; arr[rear] = n; rear = (rear + 1) % maxSize; //将rear后移，这里必须考虑取模，可能是一圈两圈 n圈 &#125; public int getQueue() &#123; if (isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; int val = arr[front]; front = (front + 1) % maxSize; return val; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; //思路 从front开始遍历，遍历多少个元素 //遍历整个数组数据，(rear+maxSize-front)%maxsize for(int i=0;i&lt;front+size();i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i%maxSize, arr[i%maxSize]); &#125; &#125; public int size() &#123; return (rear+maxSize-front)%maxSize; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front]; &#125; &#125; ##学校的OJ题 此题只需将 0-k-1 的数据入队，再将k-m的数据输出，再将 0-K-1的数据出队即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) &#123; int m,n,i; m=scanner.nextInt(); n=scanner.nextInt(); if(m==0&amp;&amp;n==0) break; int data[]=new int[m+1]; queue Queue = new queue(m); for(i=0;i&lt;m;i++) &#123; data[i]=scanner.nextInt(); &#125; for(i=0;i&lt;n;i++) &#123; Queue.add(data[i]); &#125; for(;i&lt;m;i++) &#123; System.out.printf(&quot;%d &quot;,data[i]); &#125; for(i=0;i&lt;n;i++) &#123; int res=Queue.getqueue(); if(i==n-1) System.out.printf(&quot;%d\\n&quot;,res); else System.out.printf(&quot;%d &quot;,res); &#125; &#125; &#125; &#125;class queue&#123; Scanner scanner =new Scanner(System.in); private int rear; private int front; private int Maxsize; private int[] arr; public queue(int maxsize) &#123; Maxsize=maxsize; arr=new int[Maxsize]; rear=-1; front=-1; &#125; public void add(int n) &#123; arr[++rear]=n; &#125; public int getqueue() &#123; return arr[++front]; &#125; &#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-01-13T13:36:50.434Z","updated":"2022-01-14T08:39:47.842Z","comments":true,"path":"2022/01/13/hello-world/","link":"","permalink":"http://example.com/2022/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}],"categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"基础","slug":"基础","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}