{"meta":{"title":"欢迎来到我的个人博客","subtitle":"","description":"","author":"Yekezhen","url":"http://example.com","root":"/"},"pages":[{"title":"文章归档","date":"2022-01-14T04:06:23.570Z","updated":"2022-01-14T03:59:14.282Z","comments":true,"path":"archive.html","permalink":"http://example.com/archive.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-14T03:55:17.000Z","updated":"2022-01-14T03:56:40.162Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"队列","slug":"ceshi","date":"2022-01-14T12:49:31.123Z","updated":"2022-01-14T12:53:40.760Z","comments":true,"path":"2022/01/14/ceshi/","link":"","permalink":"http://example.com/2022/01/14/ceshi/","excerpt":"","text":"队列是一种线型的结构，与栈不同，队列的数据是先进先出。##数组单向队列 单向队列只能使用一次，即达到最大容量后无法继续增添删改，由Maxsize（最大容量），rear（队列尾）和front（队列头）三个变量进行数据的进队和出队 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129$ public class Main&#123; public static void main(String[] args) &#123; // ArrayQueue arrayQueue = new ArrayQueue(3); char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125;class ArrayQueue&#123; private int maxSize; private int front; private int rear; private int[] arr; //创建队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize=arrMaxSize; arr=new int[maxSize]; front =-1;//指向队列的头部，分析出front是队列头的前一个位置 rear=-1;//指向队列尾，指向队列尾的数据 &#125; //判断队列是否满 public boolean isFull() &#123; return rear==maxSize-1; &#125; public boolean isEmpty() &#123; return rear==front; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if(isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; rear++;//让rear后移 arr[rear]=n; &#125; //出队列 public int getQueue() &#123; if(isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; front++;//后移到第一个 return arr[front]; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; for(int i=0;i&lt;arr.length;i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i, arr[i]); &#125; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front+1]; &#125;&#125; ##环形队列 与单向队列不同，环形队列可以多次反复的使用，其原因是rear与front指针在指向下一个数组位置是都要对maxsize进行取余 因此可以反复使用 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127$ public class Main&#123; public static void main(String[] args) &#123; System.out.printf(&quot;测试数组环形队列~~~\\n&quot;); CircleArray arrayQueue = new CircleArray(4); // 设置为4，实则为3 //因为预留了一个位置 char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125; class CircleArray &#123; private int maxSize; private int front; private int rear; private int[] arr; public CircleArray(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; public boolean isEmpty() &#123; return front == rear; &#125; public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; arr[rear] = n; rear = (rear + 1) % maxSize; //将rear后移，这里必须考虑取模，可能是一圈两圈 n圈 &#125; public int getQueue() &#123; if (isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; int val = arr[front]; front = (front + 1) % maxSize; return val; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; //思路 从front开始遍历，遍历多少个元素 //遍历整个数组数据，(rear+maxSize-front)%maxsize for(int i=0;i&lt;front+size();i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i%maxSize, arr[i%maxSize]); &#125; &#125; public int size() &#123; return (rear+maxSize-front)%maxSize; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front]; &#125; &#125; ##学校的OJ题 此题只需将 0-k-1 的数据入队，再将k-m的数据输出，再将 0-K-1的数据出队即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) &#123; int m,n,i; m=scanner.nextInt(); n=scanner.nextInt(); if(m==0&amp;&amp;n==0) break; int data[]=new int[m+1]; queue Queue = new queue(m); for(i=0;i&lt;m;i++) &#123; data[i]=scanner.nextInt(); &#125; for(i=0;i&lt;n;i++) &#123; Queue.add(data[i]); &#125; for(;i&lt;m;i++) &#123; System.out.printf(&quot;%d &quot;,data[i]); &#125; for(i=0;i&lt;n;i++) &#123; int res=Queue.getqueue(); if(i==n-1) System.out.printf(&quot;%d\\n&quot;,res); else System.out.printf(&quot;%d &quot;,res); &#125; &#125; &#125; &#125;class queue&#123; Scanner scanner =new Scanner(System.in); private int rear; private int front; private int Maxsize; private int[] arr; public queue(int maxsize) &#123; Maxsize=maxsize; arr=new int[Maxsize]; rear=-1; front=-1; &#125; public void add(int n) &#123; arr[++rear]=n; &#125; public int getqueue() &#123; return arr[++front]; &#125; &#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-01-13T13:36:50.434Z","updated":"2022-01-14T08:39:47.842Z","comments":true,"path":"2022/01/13/hello-world/","link":"","permalink":"http://example.com/2022/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}],"categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}