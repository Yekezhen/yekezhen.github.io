{"meta":{"title":"欢迎来到我的个人博客","subtitle":"","description":"","author":"Yekezhen","url":"http://example.com","root":"/"},"pages":[{"title":"文章归档","date":"2022-01-14T04:06:23.570Z","updated":"2022-01-14T03:59:14.282Z","comments":true,"path":"archive.html","permalink":"http://example.com/archive.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-14T03:55:17.000Z","updated":"2022-01-14T03:56:40.162Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"链表","slug":"链表","date":"2022-01-16T11:56:16.000Z","updated":"2022-01-16T12:27:53.361Z","comments":true,"path":"2022/01/16/链表/","link":"","permalink":"http://example.com/2022/01/16/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"Quick Start链表是一种物理存储单元上非连续、非顺序的存储结构，由一个或多个结点组成，节点可分为数据域与指针域。链表在插入数据时的复杂度比线性表和顺序表低很多，因此当一组很庞大数据需要管理时，采用链表可以大大增加计算机效率。 本文介绍两种类型的链表 ① 单向链表 ② 环状链表 单向链表单向链表只需每次用辅助指针将链表遍历至最后一个节点，再将最后一个节点的指针域指向要插入的节点即可。或是用头插法，双指针法都可以。 java版本代码实现简单的单向链表的增删添改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package Main;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; HeroNode hero1 = new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;); HeroNode hero2 = new HeroNode(2,&quot;卢俊义&quot;,&quot;玉麒麟&quot;); HeroNode hero3 = new HeroNode(3,&quot;吴用&quot;,&quot;智多星&quot;); HeroNode hero4 = new HeroNode(3,&quot;小卢&quot;,&quot;玉麒麟&quot;); SingleLinkedlist single = new SingleLinkedlist(); single.addByorder(hero2);single.addByorder(hero1);single.addByorder(hero3); single.list(); single.Del(2); System.out.printf(&quot;-----删除后-----------\\n&quot;); single.list(); System.out.printf(&quot;-----修改后-----------\\n&quot;); single.modify(hero4); single.list(); &#125;&#125;class HeroNode&#123; public int no; public String name; public String nickname; public HeroNode next; public HeroNode(int Hno,String Hname,String Hnickname) &#123; //构造器 this.no=Hno; this.name=Hname; this.nickname=Hnickname; &#125; @Override public String toString() &#123; return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;; &#125;&#125;class SingleLinkedlist&#123; private HeroNode head= new HeroNode(0,&quot;&quot;,&quot;&quot;); public void add(HeroNode node) &#123; HeroNode cur=head; while(true) &#123; if(cur.next==null) &#123;//遍历到最后一个 break; &#125; cur=cur.next; &#125; cur.next=node; //将新的Node结点插入进去 &#125; public void list() &#123; HeroNode cur=head.next; if(head.next==null) &#123; System.out.printf(&quot;链表为空&quot;); return; &#125; while(cur!=null) &#123; System.out.println(cur); cur=cur.next; &#125; &#125; public void addByorder(HeroNode node) &#123; if(head.next==null) &#123; //第一种情况，如果没有结点 那node就为第一个结点 head.next=node; return; &#125; else if(head.next.no&gt;node.no) &#123; 第二种情况 若node结点的num值比第一个结点的还小 node.next=head.next; head.next=node; return; &#125; else &#123; HeroNode cur=head,pre = null; while(cur!=null) &#123; if(cur.no&gt;node.no) &#123; //第三种，插入在中间和最后一个 break; &#125; pre=cur; cur=cur.next; &#125; node.next=cur; pre.next=node; return; &#125; &#125; public void Del(int no) &#123; //按照序号来找即可 if(head.next==null) &#123; System.out.printf(&quot;链表不存在\\n&quot;); return; &#125; HeroNode cur=head.next; boolean flag=false; while(cur!=null) &#123; if(cur.next.no==no) &#123; //这里必须是cur的下一个结点的值 flag=true; break; &#125; cur=cur.next; &#125; if(flag) &#123; cur.next=cur.next.next; return; &#125; else &#123; System.out.printf(&quot;不存在该节点\\n&quot;); return; &#125; &#125; public void modify(HeroNode node) &#123; if(head.next==null) &#123; System.out.printf(&quot;链表不存在\\n&quot;); return; &#125; HeroNode cur=head.next; boolean flag=false; while(cur!=null) &#123; if(cur.no==node.no) &#123; flag=true; break; &#125; cur=cur.next; &#125; if(flag) &#123; cur.name=node.name; cur.nickname=node.nickname; return; &#125; else &#123; System.out.printf(&quot;不存在该节点\\n&quot;); return; &#125; &#125; &#125; 效果图 环形链表环形链表通过 一个辅助指针（first）指向链表的第一个结点，再通过一个cur指针遍历链表，之后将cur指向的结点的next域指向first 形成环状 java版本代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package Main;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); CircleSingleLinkedList circle = new CircleSingleLinkedList(); circle.addBoy(5); circle.list(); &#125; &#125;class CircleSingleLinkedList&#123; private Boy first =new Boy(-1); public void addBoy(int nums) &#123; if(nums&lt;1) &#123; System.out.printf(&quot;数据错误\\n&quot;); return; &#125; Boy curBoy=null;//辅助指针 for(int i=1;i&lt;=nums;i++) &#123; Boy boy=new Boy(i); if(i==1) &#123; //如果是第一个 就交代first指针与cur指针 first=boy; first.setNext(first); curBoy=first; &#125;else &#123; curBoy.setNext(boy); //cur依次向后移，但是first始终不变 boy.setNext(first); //这步是为了连成环状 curBoy=boy; &#125; &#125; &#125; public void list() &#123; if(first==null) &#123; System.out.printf(&quot;链表为空，没有数据\\n&quot;); return; &#125; Boy cur=first; while(cur!=null) &#123; if(cur.getNext()==first) &#123; System.out.printf(&quot;%d\\n&quot;,cur.getNo()); break; &#125; else &#123; System.out.printf(&quot;%d-&gt;&quot;,cur.getNo()); &#125; cur=cur.getNext(); &#125; &#125; &#125;class Boy&#123; private int no; private Boy next; public Boy(int no) &#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125; 约瑟夫环 具体思路 java代码（老版本oj能AC,不知道为什么新平台一直提示scanner错误） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); CircleSingleLinkedList circle = new CircleSingleLinkedList(); while(scanner.hasNext()) &#123; int Case=0; int data[]=new int[100]; int T=scanner.nextInt(),i; for(i=0;i&lt;T;i++) &#123; int n,m; Case++; n=scanner.nextInt(); m=scanner.nextInt(); circle.addBoy(n); for(int j=0;j&lt;n;j++) &#123; data[j]=scanner.nextInt(); &#125; System.out.printf(&quot;Case %d:&quot;,Case); circle.countBoy(1,m,n,data); &#125; &#125; scanner.close();&#125; &#125;class CircleSingleLinkedList&#123; private Boy first =new Boy(-1); public void addBoy(int nums) &#123; if(nums&lt;1) &#123; System.out.printf(&quot;数据错误\\n&quot;); return; &#125; Boy curBoy=null; for(int i=1;i&lt;=nums;i++) &#123; Boy boy=new Boy(i); if(i==1) &#123; first=boy; first.setNext(first); curBoy=first; &#125;else &#123; curBoy.setNext(boy); boy.setNext(first); curBoy=boy; &#125; &#125; &#125; public void list() &#123; if(first==null) &#123; System.out.printf(&quot;链表为空，没有数据\\n&quot;); return; &#125; Boy cur=first; while(cur!=null) &#123; if(cur.getNext()==first) &#123; System.out.printf(&quot;%d\\n&quot;,cur.getNo()); break; &#125; else &#123; System.out.printf(&quot;%d-&gt;&quot;,cur.getNo()); &#125; cur=cur.getNext(); &#125; &#125; public void countBoy(int startNo,int countNum,int nums,int data[]) &#123; if(first==null||startNo&lt;1||startNo&gt;nums) &#123; System.out.printf(&quot;参数错误&quot;); return; &#125; Boy helper = first; while(true) &#123; if(helper.getNext()==first) &#123; break; &#125; helper=helper.getNext(); &#125; for(int j=0;j&lt;startNo-1;j++) &#123; 先指到开始的位置 first=first.getNext(); helper=helper.getNext(); &#125; while(true) &#123; if(helper==first) &#123; break; &#125; for(int j=0;j&lt;countNum-1;j++) &#123; //移动几次 first=first.getNext(); helper=helper.getNext(); &#125; System.out.printf(&quot;%d-&gt;&quot;,first.getNo()); countNum=data[first.getNo()-1]; first=first.getNext(); helper.setNext(first); &#125; System.out.printf(&quot;%d\\n&quot;,first.getNo()); &#125; &#125;class Boy&#123; private int no; private Boy next; public Boy(int no) &#123; this.no=no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"队列","slug":"ceshi","date":"2022-01-14T12:49:31.123Z","updated":"2022-01-14T12:57:57.360Z","comments":true,"path":"2022/01/14/ceshi/","link":"","permalink":"http://example.com/2022/01/14/ceshi/","excerpt":"","text":"队列是一种线型的结构，与栈不同，队列的数据是先进先出。##数组单向队列 单向队列只能使用一次，即达到最大容量后无法继续增添删改，由Maxsize（最大容量），rear（队列尾）和front（队列头）三个变量进行数据的进队和出队 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129$ public class Main&#123; public static void main(String[] args) &#123; // ArrayQueue arrayQueue = new ArrayQueue(3); char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125;class ArrayQueue&#123; private int maxSize; private int front; private int rear; private int[] arr; //创建队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize=arrMaxSize; arr=new int[maxSize]; front =-1;//指向队列的头部，分析出front是队列头的前一个位置 rear=-1;//指向队列尾，指向队列尾的数据 &#125; //判断队列是否满 public boolean isFull() &#123; return rear==maxSize-1; &#125; public boolean isEmpty() &#123; return rear==front; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if(isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; rear++;//让rear后移 arr[rear]=n; &#125; //出队列 public int getQueue() &#123; if(isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; front++;//后移到第一个 return arr[front]; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; for(int i=0;i&lt;arr.length;i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i, arr[i]); &#125; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front+1]; &#125;&#125; ##环形队列 与单向队列不同，环形队列可以多次反复的使用，其原因是rear与front指针在指向下一个数组位置是都要对maxsize进行取余 因此可以反复使用 JAVA版代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127$ public class Main&#123; public static void main(String[] args) &#123; System.out.printf(&quot;测试数组环形队列~~~\\n&quot;); CircleArray arrayQueue = new CircleArray(4); // 设置为4，实则为3 //因为预留了一个位置 char key=&#x27; &#x27;; Scanner scanner = new Scanner(System.in); boolean loop=true; while(loop) &#123; System.out.printf(&quot;s(show):显示队列\\n&quot;); System.out.printf(&quot;e(exit);退出\\n&quot;); System.out.printf(&quot;a(add):添加数据到队列\\n&quot;); System.out.printf(&quot;g(get):获取队列数据\\n&quot;); System.out.printf(&quot;h(head):获取队列头部\\n&quot;); key=scanner.next().charAt(0); switch(key) &#123; case &#x27;s&#x27;: arrayQueue.showQueue(); break; case &#x27;a&#x27;: System.out.printf(&quot;请输入一个数:\\n&quot;); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case &#x27;g&#x27;: try&#123; int res=arrayQueue.getQueue(); System.out.printf(&quot;取出的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;h&#x27;: try&#123; int res=arrayQueue.headQueue(); System.out.printf(&quot;队列头的数据是%d\\n&quot;,res); &#125;catch(Exception e) &#123; //TODO: handle exception System.out.println(e.getMessage()); &#125; break; case &#x27;e&#x27;: scanner.close(); loop=false; break; default: break; &#125; &#125; System.out.printf(&quot;程序退出~~\\n&quot;); &#125;&#125; class CircleArray &#123; private int maxSize; private int front; private int rear; private int[] arr; public CircleArray(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; public boolean isEmpty() &#123; return front == rear; &#125; public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.printf(&quot;队列满\\n&quot;); return; &#125; arr[rear] = n; rear = (rear + 1) % maxSize; //将rear后移，这里必须考虑取模，可能是一圈两圈 n圈 &#125; public int getQueue() &#123; if (isEmpty()) &#123; //抛出异常 throw new RuntimeException(&quot;队列空，不能获取数据&quot;); &#125; int val = arr[front]; front = (front + 1) % maxSize; return val; &#125; public void showQueue() &#123; if(isEmpty()) &#123; System.out.printf(&quot;队列为空，没有数据~~&quot;); return; &#125; //思路 从front开始遍历，遍历多少个元素 //遍历整个数组数据，(rear+maxSize-front)%maxsize for(int i=0;i&lt;front+size();i++) &#123; System.out.printf(&quot;arr[%d]=%d\\n&quot;, i%maxSize, arr[i%maxSize]); &#125; &#125; public int size() &#123; return (rear+maxSize-front)%maxSize; &#125; public int headQueue() &#123; if(isEmpty()) &#123; throw new RuntimeException(&quot;空，没有数据&quot;); &#125; return arr[front]; &#125; &#125; ##学校的OJ题 此题只需将 0-k-1 的数据入队，再将k-m的数据输出，再将 0-K-1的数据出队即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) &#123; int m,n,i; m=scanner.nextInt(); n=scanner.nextInt(); if(m==0&amp;&amp;n==0) break; int data[]=new int[m+1]; queue Queue = new queue(m); for(i=0;i&lt;m;i++) &#123; data[i]=scanner.nextInt(); &#125; for(i=0;i&lt;n;i++) &#123; Queue.add(data[i]); &#125; for(;i&lt;m;i++) &#123; System.out.printf(&quot;%d &quot;,data[i]); &#125; for(i=0;i&lt;n;i++) &#123; int res=Queue.getqueue(); if(i==n-1) System.out.printf(&quot;%d\\n&quot;,res); else System.out.printf(&quot;%d &quot;,res); &#125; &#125; &#125; &#125;class queue&#123; Scanner scanner =new Scanner(System.in); private int rear; private int front; private int Maxsize; private int[] arr; public queue(int maxsize) &#123; Maxsize=maxsize; arr=new int[Maxsize]; rear=-1; front=-1; &#125; public void add(int n) &#123; arr[++rear]=n; &#125; public int getqueue() &#123; return arr[++front]; &#125; &#125;","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-01-13T13:36:50.434Z","updated":"2022-01-14T08:39:47.842Z","comments":true,"path":"2022/01/13/hello-world/","link":"","permalink":"http://example.com/2022/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}],"categories":[{"name":"数构算法","slug":"数构算法","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数构算法/Leetcode","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"oj","slug":"数构算法/Leetcode/oj","permalink":"http://example.com/categories/%E6%95%B0%E6%9E%84%E7%AE%97%E6%B3%95/Leetcode/oj/"}],"tags":[]}